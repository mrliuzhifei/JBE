C51 COMPILER V9.60.0.0   CO2                                                               11/01/2022 15:53:28 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE CO2
OBJECT MODULE PLACED IN .\Output\CO2.obj
COMPILER INVOKED BY: d:\Keil_v5\C51\BIN\C51.EXE ..\..\..\UserCode\User\src\CO2.c LARGE OPTIMIZE(7,SPEED) BROWSE INCDIR(.
                    -.\..\..\UserCode\Device\Include;..\..\..\UserCode\StdDriver\inc;..\..\..\UserCode\User\ins;..\..\..\UserCode\StdDriver\s
                    -rc;..\..\..\UserCode\StdDriver\lib) DEBUG OBJECTEXTEND PRINT(.\LST\CO2.lst) TABS(2) OBJECT(.\Output\CO2.obj)

line level    source

   1          #include "ML51.h"
   2          #include "BC3602.h"
   3          //#define BC3602_RX
   4          typedef struct CO2_Send_Data_t
   5          {
   6            uint8_t SendBuf[10];       //发送数组
   7            uint8_t SendHead;           //发送数据帧头
   8            uint8_t SendLen;            //发送数据长度
   9            CO2_Cmd_s SendCmd;            //发送数据的命令
  10            uint8_t SendCs;             //发送数据的校验和
  11          }CO2_Send_Data_t;
  12          
  13          
  14          typedef struct CO2_Read_Data_t
  15          {
  16            uint8_t ReadBuf[15];        //接收数组
  17            uint8_t CO2DataBuf[15];     //接收数组
  18            uint8_t ReadHead;           //接收数据帧头
  19            uint8_t ReadLen;            //接收数据长度
  20            CO2_Cmd_s ReadCmd;          //接收数据的命令
  21            uint8_t ReadCs;             //接收数据的校验和
  22            
  23          }CO2_Read_Data_t;
  24          
  25          typedef struct CO2_Data_t
  26          {
  27            CO2_Send_Data_t CO2_Send_Data;      
  28            CO2_Read_Data_t CO2_Read_Data;   
  29            uint16_t CO2Value;  
  30            Uart1_Sta_s Uart1_Sta;
  31            uint8_t Recieve_count;
  32            uint8_t uart_recievedate_temp;//串口接收数据
  33          }CO2_Data_t;
  34          
  35          CO2_Data_t  CO2_Data;
  36          #define JBE CO2_Data
  37          
  38          void CO2_Init(void)
  39          {
  40   1       GPIO_SetMode(Port2 ,BIT1,GPIO_MODE_PUSHPULL);  
  41   1       P21=1;
  42   1      }
  43            
  44            
  45          void Get_CO2Valu(void)
  46          {
  47   1      JBE.CO2_Send_Data.SendHead=0x11;
  48   1      JBE.CO2_Send_Data.SendLen=0x01;
  49   1      JBE.CO2_Send_Data.SendCmd=R_CO2Valu;
  50   1      JBE.CO2_Send_Data.SendCs=256-(JBE.CO2_Send_Data.SendHead+JBE.CO2_Send_Data.SendLen+JBE.CO2_Send_Data.SendC
             -md);
  51   1      JBE.CO2_Send_Data.SendBuf [0]=JBE.CO2_Send_Data.SendHead;
  52   1      JBE.CO2_Send_Data.SendBuf [1]=JBE.CO2_Send_Data.SendLen;
C51 COMPILER V9.60.0.0   CO2                                                               11/01/2022 15:53:28 PAGE 2   

  53   1      JBE.CO2_Send_Data.SendBuf [2]=JBE.CO2_Send_Data.SendCmd;
  54   1      JBE.CO2_Send_Data.SendBuf [3]=JBE.CO2_Send_Data.SendCs ;  
  55   1      if(JBE.Uart1_Sta==uart_state_wait)Uart1senddata(&JBE.CO2_Send_Data.SendBuf [0],JBE.CO2_Send_Data.SendLen+3
             -);
  56   1      
  57   1      }
  58          
  59          void Get_CO2_VersionNum(void)
  60          {
  61   1      JBE.CO2_Send_Data.SendHead=0x11;
  62   1      JBE.CO2_Send_Data.SendLen=0x01;
  63   1      JBE.CO2_Send_Data.SendCmd=R_Version_Num;
  64   1      JBE.CO2_Send_Data.SendCs=256-(JBE.CO2_Send_Data.SendHead+JBE.CO2_Send_Data.SendLen+JBE.CO2_Send_Data.SendC
             -md);
  65   1      JBE.CO2_Send_Data.SendBuf [0]=JBE.CO2_Send_Data.SendHead;
  66   1      JBE.CO2_Send_Data.SendBuf [1]=JBE.CO2_Send_Data.SendLen;
  67   1      JBE.CO2_Send_Data.SendBuf [2]=JBE.CO2_Send_Data.SendCmd;
  68   1      JBE.CO2_Send_Data.SendBuf [3]=JBE.CO2_Send_Data.SendCs ;  
  69   1      if(JBE.Uart1_Sta==uart_state_wait)Uart1senddata(&JBE.CO2_Send_Data.SendBuf [0],JBE.CO2_Send_Data.SendLen+3
             -);
  70   1      
  71   1      }
  72          
  73          /* UART1 interrupt subroutine */
  74          void UART1_ISR(void) interrupt 15
  75          {
  76   1          _push_(SFRS);
  77   1          if (RI_1)
  78   1          {
  79   2              JBE.uart_recievedate_temp=SBUF1;
  80   2              if(JBE.Uart1_Sta==uart_state_wait)
  81   2              {
  82   3               if(JBE.uart_recievedate_temp==0x16)       //接收到了帧头
  83   3               {
  84   4                memset(&JBE.CO2_Read_Data.ReadBuf,0,sizeof(JBE.CO2_Read_Data.ReadBuf));//接收数组清零          
  85   4                JBE.CO2_Read_Data.ReadBuf[0]=JBE.uart_recievedate_temp;
  86   4                JBE.Uart1_Sta=uart_state_recievebusy;
  87   4               }
  88   3               
  89   3              } 
  90   2              else if(JBE.Uart1_Sta==uart_state_recievebusy)
  91   2               {
  92   3                JBE.Recieve_count++;
  93   3                JBE.CO2_Read_Data.ReadBuf[JBE.Recieve_count]=JBE.uart_recievedate_temp;
  94   3                if(JBE.Recieve_count==(JBE.CO2_Read_Data.ReadBuf[1]+2))
  95   3                {
  96   4                JBE.Uart1_Sta=uart_state_recievefinish;              //接收到的个数达到了以后结束接收
  97   4                }
  98   3               }        
  99   2         
 100   2              RI_1=0;                             /* clear reception flag for next reception */
 101   2          }
 102   1          _pop_(SFRS);
 103   1      }
 104          
 105          void Recieve_Data_Analysis(void)
 106          {
 107   1        static uint16_t Times=0;
 108   1      if(JBE.Uart1_Sta==uart_state_recievefinish)
 109   1      {
 110   2        
 111   2        if(Get_Cs(JBE.Recieve_count)==JBE.CO2_Read_Data.ReadBuf[JBE.Recieve_count])
C51 COMPILER V9.60.0.0   CO2                                                               11/01/2022 15:53:28 PAGE 3   

 112   2        {
 113   3        memcpy(JBE.CO2_Read_Data.CO2DataBuf,JBE.CO2_Read_Data.ReadBuf,15);
 114   3        JBE.Uart1_Sta=uart_state_wait;
 115   3        JBE.CO2Value=JBE.CO2_Read_Data.CO2DataBuf[3]*256+JBE.CO2_Read_Data.CO2DataBuf[4];
 116   3        JBE.Recieve_count=0;
 117   3        Times=0;
 118   3        }
 119   2        else 
 120   2        {
 121   3        JBE.Uart1_Sta=uart_state_wait;
 122   3        JBE.Recieve_count=0;
 123   3        Times=0;    
 124   3        }
 125   2        
 126   2      }
 127   1      else if(JBE.Uart1_Sta!=uart_state_wait)
 128   1      { 
 129   2         Times++;
 130   2        if(Times>1000)
 131   2        {
 132   3        JBE.Uart1_Sta=uart_state_wait;
 133   3        JBE.Recieve_count=0;
 134   3        Times=0;
 135   3        }
 136   2        
 137   2      }
 138   1      
 139   1      
 140   1      }
 141          
 142          uint8_t Get_Cs(uint8_t Lens)
 143          {
 144   1       uint16_t Sum=0;
 145   1       uint8_t i=0;
 146   1       uint8_t Cs_r=0;
 147   1       for(i=0;i<Lens;i++)
 148   1       {
 149   2        Sum=Sum+JBE.CO2_Read_Data.ReadBuf[i];
 150   2       }
 151   1       Cs_r=256-Sum;
 152   1       return Cs_r;
 153   1      }
 154          
 155          void Display_Co2(Co2DisMod_s Dis_Mod)
 156          {
 157   1       uint8_t co2gw,co2sw,co2bw,co2qw;
 158   1       uint16_t C02Value_Dis;
 159   1       #ifdef BC3602_RX
               co2qw=RF_RXFIFOSAVE[0]/1000;
               co2bw=RF_RXFIFOSAVE[0]%1000/100;
               co2sw=RF_RXFIFOSAVE[0]%100/10;
               co2gw=RF_RXFIFOSAVE[0]%10; 
               ShowDigit(4,co2gw,0);
               if(C02Value_Dis>=10)  ShowDigit(3, co2sw,0); 
               if(C02Value_Dis>=100) ShowDigit(2, co2bw,0);
               if(C02Value_Dis>=1000)ShowDigit(1, co2qw,0);
                
               /*#ifdef BC3602_RX
               co2qw=RF_RXFIFO[0]/1000;
               co2bw=RF_RXFIFO[0]%1000/100;
               co2sw=RF_RXFIFO[0]%100/10;
               co2gw=RF_RXFIFO[0]%10; 
C51 COMPILER V9.60.0.0   CO2                                                               11/01/2022 15:53:28 PAGE 4   

               ShowDigit(4,co2gw,0);
               if(C02Value_Dis>=10)  ShowDigit(3, co2sw,0); 
               if(C02Value_Dis>=100) ShowDigit(2, co2bw,0);
               if(C02Value_Dis>=1000)ShowDigit(1, co2qw,0);*/
               #else
 179   1       if(Dis_Mod==Current_Valu)
 180   1       {
 181   2        
 182   2       C02Value_Dis=JBE.CO2Value;    
 183   2       }
 184   1       else if(Dis_Mod==Max_Valu_24h)
 185   1       {
 186   2       LCD_SetOnePixel(2, 9, Enable);
 187   2       LCD_SetOnePixel(3, 9, Enable);  
 188   2       C02Value_Dis=Get_Max_Valu_CO2_24h();
 189   2       } 
 190   1       else if(Dis_Mod==Avg_Valu_24h)
 191   1       {
 192   2       LCD_SetOnePixel(1, 9, Enable);
 193   2       LCD_SetOnePixel(3, 9, Enable);  
 194   2       C02Value_Dis=Get_Avg_Valu_CO2_24h();
 195   2       }
 196   1       co2qw=C02Value_Dis/1000;
 197   1       co2bw=C02Value_Dis%1000/100;
 198   1       co2sw=C02Value_Dis%100/10;
 199   1       co2gw=C02Value_Dis%10; 
 200   1       ShowDigit(4,co2gw,0);
 201   1       if(C02Value_Dis>=10)  ShowDigit(3, co2sw,0); 
 202   1       if(C02Value_Dis>=100) ShowDigit(2, co2bw,0);
 203   1       if(C02Value_Dis>=1000)ShowDigit(1, co2qw,0);
 204   1       #endif
 205   1       
 206   1       
 207   1      }
 208          
 209          uint16_t Get_Co2Value(void)
 210          {
 211   1      return JBE.CO2Value;
 212   1      }
 213          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    838    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     55       6
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
