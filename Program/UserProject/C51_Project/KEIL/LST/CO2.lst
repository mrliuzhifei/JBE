C51 COMPILER V9.60.0.0   CO2                                                               10/31/2022 08:45:42 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE CO2
OBJECT MODULE PLACED IN .\Output\CO2.obj
COMPILER INVOKED BY: d:\Keil_v5\C51\BIN\C51.EXE ..\..\..\UserCode\User\src\CO2.c LARGE OPTIMIZE(7,SPEED) BROWSE INCDIR(.
                    -.\..\..\UserCode\Device\Include;..\..\..\UserCode\StdDriver\inc;..\..\..\UserCode\User\ins;..\..\..\UserCode\StdDriver\s
                    -rc;..\..\..\UserCode\StdDriver\lib) DEBUG OBJECTEXTEND PRINT(.\LST\CO2.lst) TABS(2) OBJECT(.\Output\CO2.obj)

line level    source

   1          #include "ML51.h"
   2          #include "BC3602.h"
   3          #define BC3602_RX
   4          typedef struct CO2_Send_Data_t
   5          {
   6            uint8_t SendBuf[10];       //发送数组
   7            uint8_t SendHead;           //发送数据帧头
   8            uint8_t SendLen;            //发送数据长度
   9            CO2_Cmd_s SendCmd;            //发送数据的命令
  10            uint8_t SendCs;             //发送数据的校验和
  11          }CO2_Send_Data_t;
  12          
  13          
  14          typedef struct CO2_Read_Data_t
  15          {
  16            uint8_t ReadBuf[15];        //接收数组
  17            uint8_t CO2DataBuf[15];     //接收数组
  18            uint8_t ReadHead;           //接收数据帧头
  19            uint8_t ReadLen;            //接收数据长度
  20            CO2_Cmd_s ReadCmd;          //接收数据的命令
  21            uint8_t ReadCs;             //接收数据的校验和
  22            
  23          }CO2_Read_Data_t;
  24          
  25          typedef struct CO2_Data_t
  26          {
  27            CO2_Send_Data_t CO2_Send_Data;      
  28            CO2_Read_Data_t CO2_Read_Data;   
  29            uint16_t CO2Value;  
  30            Uart1_Sta_s Uart1_Sta;
  31            uint8_t Recieve_count;
  32            uint8_t uart_recievedate_temp;//串口接收数据
  33          }CO2_Data_t;
  34          
  35          CO2_Data_t  CO2_Data;
  36          #define JBE CO2_Data
  37          
  38          
  39          void Get_CO2Valu(void)
  40          {
  41   1      JBE.CO2_Send_Data.SendHead=0x11;
  42   1      JBE.CO2_Send_Data.SendLen=0x01;
  43   1      JBE.CO2_Send_Data.SendCmd=R_CO2Valu;
  44   1      JBE.CO2_Send_Data.SendCs=256-(JBE.CO2_Send_Data.SendHead+JBE.CO2_Send_Data.SendLen+JBE.CO2_Send_Data.SendC
             -md);
  45   1      JBE.CO2_Send_Data.SendBuf [0]=JBE.CO2_Send_Data.SendHead;
  46   1      JBE.CO2_Send_Data.SendBuf [1]=JBE.CO2_Send_Data.SendLen;
  47   1      JBE.CO2_Send_Data.SendBuf [2]=JBE.CO2_Send_Data.SendCmd;
  48   1      JBE.CO2_Send_Data.SendBuf [3]=JBE.CO2_Send_Data.SendCs ;  
  49   1      if(JBE.Uart1_Sta==uart_state_wait)Uart1senddata(&JBE.CO2_Send_Data.SendBuf [0],JBE.CO2_Send_Data.SendLen+3
             -);
  50   1      
  51   1      }
C51 COMPILER V9.60.0.0   CO2                                                               10/31/2022 08:45:42 PAGE 2   

  52          
  53          void Get_CO2_VersionNum(void)
  54          {
  55   1      JBE.CO2_Send_Data.SendHead=0x11;
  56   1      JBE.CO2_Send_Data.SendLen=0x01;
  57   1      JBE.CO2_Send_Data.SendCmd=R_Version_Num;
  58   1      JBE.CO2_Send_Data.SendCs=256-(JBE.CO2_Send_Data.SendHead+JBE.CO2_Send_Data.SendLen+JBE.CO2_Send_Data.SendC
             -md);
  59   1      JBE.CO2_Send_Data.SendBuf [0]=JBE.CO2_Send_Data.SendHead;
  60   1      JBE.CO2_Send_Data.SendBuf [1]=JBE.CO2_Send_Data.SendLen;
  61   1      JBE.CO2_Send_Data.SendBuf [2]=JBE.CO2_Send_Data.SendCmd;
  62   1      JBE.CO2_Send_Data.SendBuf [3]=JBE.CO2_Send_Data.SendCs ;  
  63   1      if(JBE.Uart1_Sta==uart_state_wait)Uart1senddata(&JBE.CO2_Send_Data.SendBuf [0],JBE.CO2_Send_Data.SendLen+3
             -);
  64   1      
  65   1      }
  66          
  67          /* UART1 interrupt subroutine */
  68          void UART1_ISR(void) interrupt 15
  69          {
  70   1          _push_(SFRS);
  71   1          if (RI_1)
  72   1          {
  73   2              JBE.uart_recievedate_temp=SBUF1;
  74   2              if(JBE.Uart1_Sta==uart_state_wait)
  75   2              {
  76   3               if(JBE.uart_recievedate_temp==0x16)       //接收到了帧头
  77   3               {
  78   4                memset(&JBE.CO2_Read_Data.ReadBuf,0,sizeof(JBE.CO2_Read_Data.ReadBuf));//接收数组清零          
  79   4                JBE.CO2_Read_Data.ReadBuf[0]=JBE.uart_recievedate_temp;
  80   4                JBE.Uart1_Sta=uart_state_recievebusy;
  81   4               }
  82   3               
  83   3              } 
  84   2              else if(JBE.Uart1_Sta==uart_state_recievebusy)
  85   2               {
  86   3                JBE.Recieve_count++;
  87   3                JBE.CO2_Read_Data.ReadBuf[JBE.Recieve_count]=JBE.uart_recievedate_temp;
  88   3                if(JBE.Recieve_count==(JBE.CO2_Read_Data.ReadBuf[1]+2))
  89   3                {
  90   4                JBE.Uart1_Sta=uart_state_recievefinish;              //接收到的个数达到了以后结束接收
  91   4                }
  92   3               }        
  93   2         
  94   2              RI_1=0;                             /* clear reception flag for next reception */
  95   2          }
  96   1          _pop_(SFRS);
  97   1      }
  98          
  99          void Recieve_Data_Analysis(void)
 100          {
 101   1        static uint16_t Times=0;
 102   1      if(JBE.Uart1_Sta==uart_state_recievefinish)
 103   1      {
 104   2        
 105   2        if(Get_Cs(JBE.Recieve_count)==JBE.CO2_Read_Data.ReadBuf[JBE.Recieve_count])
 106   2        {
 107   3        memcpy(JBE.CO2_Read_Data.CO2DataBuf,JBE.CO2_Read_Data.ReadBuf,15);
 108   3        JBE.Uart1_Sta=uart_state_wait;
 109   3        JBE.CO2Value=JBE.CO2_Read_Data.CO2DataBuf[3]*256+JBE.CO2_Read_Data.CO2DataBuf[4];
 110   3        JBE.Recieve_count=0;
 111   3        Times=0;
C51 COMPILER V9.60.0.0   CO2                                                               10/31/2022 08:45:42 PAGE 3   

 112   3        }
 113   2        else 
 114   2        {
 115   3        JBE.Uart1_Sta=uart_state_wait;
 116   3        JBE.Recieve_count=0;
 117   3        Times=0;    
 118   3        }
 119   2        
 120   2      }
 121   1      else if(JBE.Uart1_Sta!=uart_state_wait)
 122   1      { 
 123   2         Times++;
 124   2        if(Times>1000)
 125   2        {
 126   3        JBE.Uart1_Sta=uart_state_wait;
 127   3        JBE.Recieve_count=0;
 128   3        Times=0;
 129   3        }
 130   2        
 131   2      }
 132   1      
 133   1      
 134   1      }
 135          
 136          uint8_t Get_Cs(uint8_t Lens)
 137          {
 138   1       uint16_t Sum=0;
 139   1       uint8_t i=0;
 140   1       uint8_t Cs_r=0;
 141   1       for(i=0;i<Lens;i++)
 142   1       {
 143   2        Sum=Sum+JBE.CO2_Read_Data.ReadBuf[i];
 144   2       }
 145   1       Cs_r=256-Sum;
 146   1       return Cs_r;
 147   1      }
 148          
 149          void Display_Co2(Co2DisMod_s Dis_Mod)
 150          {
 151   1       uint8_t co2gw,co2sw,co2bw,co2qw;
 152   1       uint16_t C02Value_Dis;
 153   1       #ifdef BC3602_RX
 154   1       co2qw=RF_RXFIFOSAVE[0]/1000;
 155   1       co2bw=RF_RXFIFOSAVE[0]%1000/100;
 156   1       co2sw=RF_RXFIFOSAVE[0]%100/10;
 157   1       co2gw=RF_RXFIFOSAVE[0]%10; 
 158   1       ShowDigit(4,co2gw,0);
 159   1       if(C02Value_Dis>=10)  ShowDigit(3, co2sw,0); 
 160   1       if(C02Value_Dis>=100) ShowDigit(2, co2bw,0);
 161   1       if(C02Value_Dis>=1000)ShowDigit(1, co2qw,0);
 162   1        
 163   1       /*#ifdef BC3602_RX
 164   1       co2qw=RF_RXFIFO[0]/1000;
 165   1       co2bw=RF_RXFIFO[0]%1000/100;
 166   1       co2sw=RF_RXFIFO[0]%100/10;
 167   1       co2gw=RF_RXFIFO[0]%10; 
 168   1       ShowDigit(4,co2gw,0);
 169   1       if(C02Value_Dis>=10)  ShowDigit(3, co2sw,0); 
 170   1       if(C02Value_Dis>=100) ShowDigit(2, co2bw,0);
 171   1       if(C02Value_Dis>=1000)ShowDigit(1, co2qw,0);*/
 172   1       #else
               if(Dis_Mod==Current_Valu)
C51 COMPILER V9.60.0.0   CO2                                                               10/31/2022 08:45:42 PAGE 4   

               {
                
               C02Value_Dis=JBE.CO2Value;    
               }
               else if(Dis_Mod==Max_Valu_24h)
               {
               LCD_SetOnePixel(2, 9, Enable);
               LCD_SetOnePixel(3, 9, Enable);  
               C02Value_Dis=Get_Max_Valu_CO2_24h();
               } 
               else if(Dis_Mod==Avg_Valu_24h)
               {
               LCD_SetOnePixel(1, 9, Enable);
               LCD_SetOnePixel(3, 9, Enable);  
               C02Value_Dis=Get_Avg_Valu_CO2_24h();
               }
               co2qw=C02Value_Dis/1000;
               co2bw=C02Value_Dis%1000/100;
               co2sw=C02Value_Dis%100/10;
               co2gw=C02Value_Dis%10; 
               ShowDigit(4,co2gw,0);
               if(C02Value_Dis>=10)  ShowDigit(3, co2sw,0); 
               if(C02Value_Dis>=100) ShowDigit(2, co2bw,0);
               if(C02Value_Dis>=1000)ShowDigit(1, co2qw,0);
               #endif
 199   1       
 200   1       
 201   1      }
*** WARNING C280 IN LINE 149 OF ..\..\..\UserCode\User\src\CO2.c: 'Dis_Mod': unreferenced local variable
 202          
 203          uint16_t Get_Co2Value(void)
 204          {
 205   1      return JBE.CO2Value;
 206   1      }
 207          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    711    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     55       6
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
