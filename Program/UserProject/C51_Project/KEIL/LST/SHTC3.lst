C51 COMPILER V9.60.0.0   SHTC3                                                             10/31/2022 08:45:43 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE SHTC3
OBJECT MODULE PLACED IN .\Output\SHTC3.obj
COMPILER INVOKED BY: d:\Keil_v5\C51\BIN\C51.EXE ..\..\..\UserCode\User\src\SHTC3.c LARGE OPTIMIZE(7,SPEED) BROWSE INCDIR
                    -(..\..\..\UserCode\Device\Include;..\..\..\UserCode\StdDriver\inc;..\..\..\UserCode\User\ins;..\..\..\UserCode\StdDriver
                    -\src;..\..\..\UserCode\StdDriver\lib) DEBUG OBJECTEXTEND PRINT(.\LST\SHTC3.lst) TABS(2) OBJECT(.\Output\SHTC3.obj)

line level    source

   1          #include "ML51.h"
   2          uint8_t Minit_Times;
   3          uint8_t Minit_Times_Hub=0;
   4          typedef enum SHTC3_Sta_s  //???????
   5          {
   6             Sleep,
   7             Wakeup,
   8             Mesured,
   9             Readstart,
  10             Readover,
  11          }SHTC3_Sta_s;
  12          
  13          typedef struct SHTC3_Data_t
  14          {
  15           uint8_t CmdBuf [2];
  16           uint8_t ReadBuf[6];
  17           SHTC3_Sta_s  SHTC3_Sta;
  18           uint16_t Temp_value;
  19           uint16_t Temp_value_mid; 
  20           uint16_t Temp_value_Intinal; 
  21           uint8_t FirstTimeGetTempFlag;  
  22           uint16_t Hub_value;
  23           uint16_t Hub_value_mid;  
  24           uint16_t Hub_value_Intinal;
  25           uint8_t crc8;  
  26          }SHTC3_Data_t;
  27          
  28          SHTC3_Data_t SHTC3_Data;
  29          #define JBE SHTC3_Data
  30          
  31          void Init_SHTC3(void)
  32          {
  33   1      JBE.SHTC3_Sta=Sleep;
  34   1      }
  35          //========================================================================================================
  36          
  37          
  38          //========================================================================================================
  39          void I2C_Error(void)
  40          {
  41   1         // while (1);    
  42   1        //Get_TempHut();
  43   1      }
  44          //========================================================================================================
  45          
  46          //--------------------------------------------------------------------------------------------
  47          
  48          //--------------------------------------------------------------------------------------------
  49          /*Ö÷»ú·¢ËÍÄ£Ê½*/
  50          void I2C_Write(UINT8 *pbuf,UINT8 len )
  51          {
  52   1           unsigned char  u8Count;
  53   1          
C51 COMPILER V9.60.0.0   SHTC3                                                             10/31/2022 08:45:43 PAGE 2   

  54   1          /* Write Step1 */
  55   1          set_I2C0CON_STA;                                      /*STAÖÃ1Î»Ö÷»ú·¢ËÍÄ£Ê½£¬Ó²¼þ·¢³öÆðÊ¼ÐÅºÅ£¬Èç¹ûÆðÊ
             -¼ÐÅºÅ·¢ËÍ³É¹¦£¬SI ÖÃ1*/                                /* Send Start bit to I2C EEPROM */
  56   1          clr_I2C0CON_SI;
  57   1          while (!(I2C0CON&SET_BIT3));                          /*SIÖÃ1ËµÃ÷ÆðÊ¼ÐÅºÅ·¢ËÍ³É¹¦*/                    
             -        /*Check SI set or not  */
  58   1         
  59   1          if (I2C0STAT != 0x08)                                 /*×´Ì¬ÂëÎª0x08µÄÊ±ºòËµÃ÷ÆðÊ¼ÐÅºÅ·¢ËÍ³É¹¦*/       
             -         /*Check status value after every step   */
  60   1              I2C_Error();
  61   1          /*·¢ËÍ´Ó»úµØÖ·ºÍÐ´±êÖ¾*/
  62   1          /* Write Step2 */
  63   1          clr_I2C0CON_STA;                                      /*STA=0*/
  64   1          I2C0DAT = (I2C_SLAVE_ADDRESS | I2C_WR);
  65   1          clr_I2C0CON_SI;
  66   1          while (!(I2C0CON&SET_BIT3));                          /*Check SI set or not */
  67   1          if (I2C0STAT != 0x18)                                 /*´Ó»úµØÖ·ÒÑ·¢£¬ÊÕµ½ÁËÓ¦´ð£¬×´Ì¬Îª0x18*/
  68   1              I2C_Error();
  69   1      
  70   1          /* Write Step3 */
  71   1          for (u8Count = 0; u8Count < len; u8Count++)     /*Ñ­»··¢ËÍ×Ô¶¨ÒåÊý¾Ý*/
  72   1          {
  73   2             
  74   2              I2C0DAT = *pbuf;
  75   2              pbuf++;
  76   2              clr_I2C0CON_SI;
  77   2              while (!(I2C0CON&SET_BIT3));                       /*Check SI set or not*/
  78   2              if (I2C0STAT != 0x28)
  79   2                  I2C_Error();
  80   2          }
  81   1      
  82   1          /* Write Step4 */
  83   1          set_I2C0CON_STO;    /*Í£Ö¹±êÖ¾Î»£¬Ö÷»úÄ£Ê½ÏÂÉèÖÃÎª1Ê±Ïò×ÜÏß·¢ËÍÍ£Ö¹ÐÅºÅ*/
  84   1          clr_I2C0CON_SI;
  85   1          while (I2C0CON&SET_BIT4); 
  86   1      
  87   1      }
  88          
  89          void I2C_Read(UINT8 *pbuf,len)
  90          {
  91   1          unsigned char  u8Count;
  92   1          /* Read Step1 */
  93   1          set_I2C0CON_STA;
  94   1          clr_I2C0CON_SI;          
  95   1          while (!(I2C0CON&SET_BIT3));                                //Check SI set or not
  96   1        if (I2C0STAT != 0x08)                         /*ÆðÊ¼Î»·¢ËÍ³É¹¦*///Check status value after every step
  97   1              I2C_Error();
  98   1      
  99   1          /* Step13 */
 100   1          clr_I2C0CON_STA;                                    //STA needs to be cleared after START codition is 
             -generated
 101   1          I2C0DAT = (I2C_SLAVE_ADDRESS | I2C_RD);       /*·¢ËÍ´Ó»úµØÖ·£¬ºÍ¶Á±êÖ¾Î»*/
 102   1          clr_I2C0CON_SI;
 103   1          while (!(I2C0CON&SET_BIT3));                                //Check SI set or not
 104   1        if (I2C0STAT != 0x40)                         /*·¢ËÍ³É¹¦ÊÕµ½´Ó»úÓ¦´ð*/
 105   1              I2C_Error();
 106   1          
 107   1          /* Step14 */
 108   1          for (u8Count = 0; u8Count <len; u8Count++)
 109   1          {
 110   2              set_I2C0CON_AA;
 111   2              clr_I2C0CON_SI;        
C51 COMPILER V9.60.0.0   SHTC3                                                             10/31/2022 08:45:43 PAGE 3   

 112   2              while (!(I2C0CON&SET_BIT3));                            //Check SI set or not
 113   2      
 114   2              if (I2C0STAT != 0x50)              
 115   2                  I2C_Error();
 116   2              
 117   2              // if (I2C0DAT != u8DAT)             
 118   2              //    I2C_Error();
 119   2              *pbuf=I2C0DAT;
 120   2               pbuf++;
 121   2          } 
 122   1          
 123   1          /* Step15 */
 124   1          clr_I2C0CON_AA;
 125   1          clr_I2C0CON_SI;
 126   1          while (!(I2C0CON&SET_BIT3));                                //Check SI set or not
 127   1          if (I2C0STAT != 0x58)
 128   1              I2C_Error();
 129   1      
 130   1          /* Step16 */
 131   1          set_I2C0CON_STO;
 132   1          clr_I2C0CON_SI;
 133   1          while (I2C0CON&SET_BIT4);                                /* Check STOP signal */ 
 134   1      }
 135          
 136          void Init_I2C(void)
 137          {
 138   1          MFP_P53_I2C0_SCL;
 139   1          P53_OPENDRAIN_MODE ;          // Modify SCL pin to Open drain mode. don't forget the pull high resiste
             -r in circuit
 140   1          MFP_P52_I2C0_SDA;
 141   1          P52_OPENDRAIN_MODE ;          // Modify SDA pin to Open drain mode. don't forget the pull high resiste
             -r in circuit
 142   1      
 143   1          SFRS = 0;
 144   1          /* Set I2C clock rate */
 145   1          I2C0CLK = I2C_CLOCK; 
 146   1      
 147   1          /* Enable I2C */
 148   1          set_I2C0CON_I2CEN;  
 149   1          JBE.SHTC3_Sta=Sleep;
 150   1          JBE.CmdBuf [0]=0x35;     //Ë¯ÃßÄ£Ê½ÏÂ·¢ËÍ»½ÐÑÃüÁî0x3517                                                 
             -                                                                                                                  
 151   1          JBE.CmdBuf [1]=0x17;
 152   1          I2C_Write(&JBE.CmdBuf,sizeof(JBE.CmdBuf));
 153   1          JBE.CmdBuf [0]=0x80;                                                                                  
             -                                                                                   
 154   1          JBE.CmdBuf [1]=0x5D;
 155   1          I2C_Write(&JBE.CmdBuf,sizeof(JBE.CmdBuf));  
 156   1      }
 157          
 158          
 159          void Get_TempHut(void)
 160          {
 161   1       #ifdef test
                
                JBE.CmdBuf [0]=0x35;     //Ë¯ÃßÄ£Ê½ÏÂ·¢ËÍ»½ÐÑÃüÁî0x3517                                                  
             -                                                                                                                 
                JBE.CmdBuf [1]=0x17;
                I2C_Write(&JBE.CmdBuf,sizeof(JBE.CmdBuf));
                
                JBE.CmdBuf [0]=0xEF;     //·¢ËÍ¶ÁÈ¡IDµÄÃüÁî0xEFC8   ²âÊÔi2cµÄÍ¨ÐÅ                                        
             -                                                                                                                   
C51 COMPILER V9.60.0.0   SHTC3                                                             10/31/2022 08:45:43 PAGE 4   

                JBE.CmdBuf [1]=0xC8;
                I2C_Write(&JBE.CmdBuf,sizeof(JBE.CmdBuf));
                I2C_Read(&JBE.ReadBuf,3);
              //  printf("\n READ ID!");
                
               #else  
 174   1       if(JBE.SHTC3_Sta==Sleep)
 175   1       {
 176   2        JBE.CmdBuf [0]=0x35;     //Ë¯ÃßÄ£Ê½ÏÂ·¢ËÍ»½ÐÑÃüÁî0x3517                                                  
             -                                                                                                                 
 177   2        JBE.CmdBuf [1]=0x17;
 178   2        I2C_Write(&JBE.CmdBuf,sizeof(JBE.CmdBuf));
 179   2        JBE.SHTC3_Sta=Wakeup;
 180   2       }
 181   1       else if(JBE.SHTC3_Sta== Wakeup)
 182   1       {
 183   2        JBE.CmdBuf [0]=0x7c;     //»½ÐÑÒÔºó·¢ËÍ0x7CA2Ñ¡ÔñÆÕÍ¨Ä£Ê½£¬¸ß¾«¶È¶ÁÈ¡
 184   2        JBE.CmdBuf [1]=0xa2;
 185   2        I2C_Write(&JBE.CmdBuf,sizeof(JBE.CmdBuf));
 186   2        JBE.SHTC3_Sta=Mesured;
 187   2       }
 188   1       else if(JBE.SHTC3_Sta== Mesured)
 189   1       {
 190   2         static unsigned char  DelayTime;
 191   2         DelayTime++;
 192   2         if(DelayTime>MeasurDlayTime)
 193   2         {
 194   3         DelayTime=0;
 195   3         JBE.SHTC3_Sta=Readstart;
 196   3         }
 197   2       }
 198   1       else if(JBE.SHTC3_Sta== Readstart)
 199   1       {
 200   2         uint8_t Temp_const=0;
 201   2         I2C_Read(&JBE.ReadBuf,sizeof(JBE.ReadBuf));
 202   2         JBE.SHTC3_Sta=Readover; 
 203   2         JBE.crc8=crc8_nrsc5(&JBE.ReadBuf[0],2);
 204   2         JBE.crc8=crc8_nrsc5(&JBE.ReadBuf[3],2);
 205   2         if(crc8_nrsc5(&JBE.ReadBuf[0],2)==JBE.ReadBuf[2]&&crc8_nrsc5(&JBE.ReadBuf[3],2)==JBE.ReadBuf[5])
 206   2         {
 207   3         JBE.Temp_value_mid=JBE.ReadBuf[0];
 208   3         JBE.Temp_value_mid=JBE.Temp_value_mid<<8;
 209   3         JBE.Temp_value_mid=JBE.Temp_value_mid+JBE.ReadBuf[1];   
 210   3         JBE.Temp_value_mid=(float)JBE.Temp_value_mid/65536*175*10;
 211   3         if(JBE.Temp_value_mid>=450)                                  //ËµÃ÷»ñµÃµÄÊÇÕýÎÂ¶È
 212   3         {
 213   4         JBE.Temp_value_mid=JBE.Temp_value_mid-450;    
 214   4         }
 215   3         else 
 216   3         {
 217   4         JBE.Temp_value_mid=450-JBE.Temp_value_mid;
 218   4         }
 219   3         if(Minit_Times<10)
 220   3         {
 221   4         if(OutTempIsHigh==1)JBE.Temp_value=JBE.Temp_value_mid-Temp_Delt*Minit_Times/10;
 222   4         else JBE.Temp_value=JBE.Temp_value_mid-15;
 223   4         }
 224   3         else if(Minit_Times<190)
 225   3         {
 226   4          if(Minit_Times<20)
 227   4          {
 228   5          Temp_const=16;
C51 COMPILER V9.60.0.0   SHTC3                                                             10/31/2022 08:45:43 PAGE 5   

 229   5          }
 230   4          else if(Minit_Times<30) 
 231   4          {
 232   5          Temp_const=21;
 233   5          } 
 234   4          else if(Minit_Times<40) 
 235   4          {
 236   5          Temp_const=25;
 237   5          } 
 238   4          else if(Minit_Times<50) 
 239   4          {
 240   5          Temp_const=28;
 241   5          } 
 242   4          else if(Minit_Times<60) 
 243   4          {
 244   5          Temp_const=30;
 245   5          } 
 246   4          else if(Minit_Times<70) 
 247   4          {
 248   5          Temp_const=31;
 249   5          } 
 250   4          else if(Minit_Times<80) 
 251   4          {
 252   5          Temp_const=32;
 253   5          } 
 254   4          else if(Minit_Times<90) 
 255   4          {
 256   5          Temp_const=33;
 257   5          } 
 258   4          else if(Minit_Times<100)  
 259   4          {
 260   5          Temp_const=34;
 261   5          } 
 262   4          else if(Minit_Times<110)  
 263   4          {
 264   5          Temp_const=35;
 265   5          }
 266   4          else if(Minit_Times<120)  
 267   4          {
 268   5          Temp_const=36;
 269   5          } 
 270   4          else if(Minit_Times<130)  
 271   4          {
 272   5          Temp_const=37;
 273   5          } 
 274   4          else if(Minit_Times<140)  
 275   4          {
 276   5          Temp_const=38;
 277   5          }   
 278   4          else if(Minit_Times<150)  
 279   4          {
 280   5          Temp_const=39;
 281   5          }
 282   4          else if(Minit_Times<160)  
 283   4          {
 284   5          Temp_const=40;
 285   5          } 
 286   4          else if(Minit_Times<170)  
 287   4          {
 288   5          Temp_const=41;
 289   5          }
 290   4          else  Temp_const=42;  
C51 COMPILER V9.60.0.0   SHTC3                                                             10/31/2022 08:45:43 PAGE 6   

 291   4          if(OutTempIsHigh==1)
 292   4          {
 293   5          
 294   5          Temp_const=42;
 295   5          if(Delt_last<1)JBE.Temp_value=JBE.Temp_value_mid-Temp_const;
 296   5          else if(Delt_last<2)JBE.Temp_value=JBE.Temp_value_mid-(1-Delt_last/15)*Temp_const; 
 297   5        
 298   5          
 299   5          //else JBE.Temp_value=JBE.Temp_value_mid-Temp_Delt;   //Èç¹ûÍâ²¿ÎÂ¶È¼±¾çÔöÕâÊ±ÎÂ¶È²»×öÐÞÕý
 300   5          else 
 301   5          {
 302   6          if(Delt_last<3)JBE.Temp_value=JBE.Temp_value_mid-42;
 303   6          else if(Delt_last<=5) JBE.Temp_value=JBE.Temp_value_mid-(1-(Delt_last-3)/5)*2-40;
 304   6          else if(Delt_last<=10) JBE.Temp_value=JBE.Temp_value_mid-(1-(Delt_last-5)/5)*5-35;
 305   6          else if(Delt_last<=16)JBE.Temp_value=JBE.Temp_value_mid-(1-(Delt_last-10)/6)*10-30;
 306   6          else if(Delt_last<=26)JBE.Temp_value=JBE.Temp_value_mid-(1-(Delt_last-16)/20)*10-25;  
 307   6          else if(Delt_last<=36)JBE.Temp_value=JBE.Temp_value_mid-(1-(Delt_last-16)/20)*10-20;      
 308   6          else if(Delt_last<=46)JBE.Temp_value=JBE.Temp_value_mid-(1-(Delt_last-36)/10)*10-15;
 309   6          else if(Delt_last<=56)JBE.Temp_value=JBE.Temp_value_mid-(1-(Delt_last-46)/10)*10-10;      
 310   6          else JBE.Temp_value=JBE.Temp_value_mid-10*(1-(Delt_last-56)/100);
 311   6          }
 312   5          }
 313   4          else
 314   4          {
 315   5          if(Delt_last<1)JBE.Temp_value=JBE.Temp_value_mid-Temp_const;
 316   5          else if(Delt_last<2)JBE.Temp_value=JBE.Temp_value_mid-(1-Delt_last/15)*Temp_const; 
 317   5          else if(Delt_last<3)JBE.Temp_value=JBE.Temp_value_mid-(1-Delt_last/15)*Temp_const; 
 318   5          else if(Delt_last<4)JBE.Temp_value=JBE.Temp_value_mid-(1-Delt_last/15)*Temp_const;  
 319   5          else if(Delt_last<5)JBE.Temp_value=JBE.Temp_value_mid-(1-Delt_last/15)*Temp_const; 
 320   5          else if(Delt_last<6)JBE.Temp_value=JBE.Temp_value_mid-(1-Delt_last/15)*Temp_const;  
 321   5          else if(Delt_last<7)JBE.Temp_value=JBE.Temp_value_mid-(1-Delt_last/15)*Temp_const;  
 322   5          else if(Delt_last<8)JBE.Temp_value=JBE.Temp_value_mid-(1-Delt_last/15)*Temp_const;  
 323   5          else if(Delt_last<9)JBE.Temp_value=JBE.Temp_value_mid-(Delt_last/15)*Temp_const;  
 324   5          else if(Delt_last<10)JBE.Temp_value=JBE.Temp_value_mid-(Delt_last/15)*Temp_const; 
 325   5          else if(Delt_last<11)JBE.Temp_value=JBE.Temp_value_mid-(Delt_last/15)*Temp_const;  
 326   5          else if(Delt_last<12)JBE.Temp_value=JBE.Temp_value_mid-(Delt_last/15)*Temp_const; 
 327   5          else if(Delt_last<13)JBE.Temp_value=JBE.Temp_value_mid-(Delt_last/15)*Temp_const;  
 328   5          else if(Delt_last<14)JBE.Temp_value=JBE.Temp_value_mid-(Delt_last/15)*Temp_const;  
 329   5          else if(Delt_last<15)JBE.Temp_value=JBE.Temp_value_mid-(Delt_last/15)*Temp_const;   
 330   5          //else JBE.Temp_value=JBE.Temp_value_mid-Temp_Delt;   //Èç¹ûÍâ²¿ÎÂ¶È¼±¾çÔöÕâÊ±ÎÂ¶È²»×öÐÞÕý
 331   5          else JBE.Temp_value=JBE.Temp_value_mid-Temp_Delt; 
 332   5          
 333   5          }
 334   4      
 335   4         }
 336   3      
 337   3        // else if(Minit_Times<90)JBE.Temp_value=JBE.Temp_value_mid-Temp_Delt-55*((80-Temp_Delt)/80);
 338   3         else
 339   3         {
 340   4           JBE.Temp_value=JBE.Temp_value_mid-Minit_Times*42/190;//(JBE.Temp_value_mid-((GET_NtcTEMP()+5-JBE.Temp_v
             -alue_mid)));
 341   4           OutTempIsHigh=0;
 342   4         }
 343   3           
 344   3         JBE.Hub_value_mid=JBE.ReadBuf[3];
 345   3         JBE.Hub_value_mid=JBE.Hub_value_mid<<8;
 346   3         JBE.Hub_value_mid=JBE.Hub_value_mid+JBE.ReadBuf[4];
 347   3         JBE.Hub_value_mid=(float)JBE.Hub_value_mid/65536*100;
 348   3         if(JBE.FirstTimeGetTempFlag==0)
 349   3         {
 350   4         JBE.Temp_value_Intinal=JBE.Temp_value_mid;
 351   4         JBE.Hub_value_Intinal =JBE.Hub_value_mid;
C51 COMPILER V9.60.0.0   SHTC3                                                             10/31/2022 08:45:43 PAGE 7   

 352   4         JBE.FirstTimeGetTempFlag=1; 
 353   4         }
 354   3         if(Minit_Times<90)
 355   3         {
 356   4         if(JBE.Hub_value_mid>30)
 357   4         {
 358   5         JBE.Hub_value=JBE.Hub_value_mid+Hub_Delt;
 359   5         }
 360   4         else JBE.Hub_value=JBE.Hub_value_mid+Hub_Delt;
 361   4         }
 362   3         else
 363   3         {
 364   4          if(JBE.Hub_value_mid>30)
 365   4         {
 366   5         JBE.Hub_value=JBE.Hub_value_mid+Minit_Times*16/90;
 367   5         }
 368   4         else JBE.Hub_value=JBE.Hub_value_mid+Minit_Times*8/90;
 369   4         
 370   4         }
 371   3         LCD_Display_TempHub(JBE.Temp_value,JBE.Hub_value);  
 372   3         
 373   3         
 374   3         }
 375   2         //LCD_Display_TempHub(JBE.Hub_value,HUB);
 376   2       }
 377   1       else if(JBE.SHTC3_Sta== Readover)
 378   1       {
 379   2        JBE.CmdBuf [0]=0xB0;
 380   2        JBE.CmdBuf [1]=0x98;
 381   2        I2C_Write(&JBE.CmdBuf,sizeof(JBE.CmdBuf));
 382   2        JBE.SHTC3_Sta=Sleep;
 383   2        Clr__TempHutStartFlag();            //ÎÂÊª¶È²âÁ¿Æô¶¯±êÖ¾ÇåÁã£¬µÈ´ýÏÂÒ»Ãë¿ªÆô
 384   2       }
 385   1       #endif
 386   1       
 387   1      }
 388          void I2C_Write_Process(UINT8 u8DAT)
 389          {
 390   1          unsigned char  u8Count;
 391   1          /* Write Step1 */
 392   1          set_I2C0CON_STA;                                      /*STAÖÃ1Î»Ö÷»ú·¢ËÍÄ£Ê½£¬Ó²¼þ·¢³öÆðÊ¼ÐÅºÅ£¬Èç¹ûÆðÊ
             -¼ÐÅºÅ·¢ËÍ³É¹¦£¬SI ÖÃ1*/                                /* Send Start bit to I2C EEPROM */
 393   1          clr_I2C0CON_SI;
 394   1          while (!(I2C0CON&SET_BIT3));                          /*SIÖÃ1ËµÃ÷ÆðÊ¼ÐÅºÅ·¢ËÍ³É¹¦*/                    
             -        /*Check SI set or not  */
 395   1          if (I2C0STAT != 0x08)                                 /*×´Ì¬ÂëÎª0x08µÄÊ±ºòËµÃ÷ÆðÊ¼ÐÅºÅ·¢ËÍ³É¹¦*/       
             -         /*Check status value after every step   */
 396   1              I2C_Error();
 397   1          /*·¢ËÍ´Ó»úµØÖ·ºÍÐ´±êÖ¾*/
 398   1          /* Write Step2 */
 399   1          clr_I2C0CON_STA;                                      /*STA=0*/
 400   1          I2C0DAT = (I2C_SLAVE_ADDRESS | I2C_WR);
 401   1          clr_I2C0CON_SI;
 402   1          while (!(I2C0CON&SET_BIT3));                          /*Check SI set or not */
 403   1          if (I2C0STAT != 0x18)                                 /*´Ó»úµØÖ·ÒÑ·¢£¬ÊÕµ½ÁËÓ¦´ð£¬×´Ì¬Îª0x18*/
 404   1              I2C_Error();
 405   1      
 406   1          /* Write Step3 */
 407   1          for (u8Count = 0; u8Count < LOOP_SIZE; u8Count++)     /*Ñ­»··¢ËÍ×Ô¶¨ÒåÊý¾Ý*/
 408   1          {
 409   2              I2C0DAT = u8DAT;
 410   2              clr_I2C0CON_SI;
C51 COMPILER V9.60.0.0   SHTC3                                                             10/31/2022 08:45:43 PAGE 8   

 411   2              while (!(I2C0CON&SET_BIT3));                       /*Check SI set or not*/
 412   2              if (I2C0STAT != 0x28)
 413   2                  I2C_Error();
 414   2      
 415   2              u8DAT = ~u8DAT;
 416   2          }
 417   1      
 418   1          /* Write Step4 */
 419   1          set_I2C0CON_STO;    /*Í£Ö¹±êÖ¾Î»£¬Ö÷»úÄ£Ê½ÏÂÉèÖÃÎª1Ê±Ïò×ÜÏß·¢ËÍÍ£Ö¹ÐÅºÅ*/
 420   1          clr_I2C0CON_SI;
 421   1          while (I2C0CON&SET_BIT4);                               /* Check STOP signal */
 422   1      }
 423            
 424          //--------------------------------------------------------------------------------------------
 425          //----  Page Read ----------------------------------------------------------------------------
 426          //--------------------------------------------------------------------------------------------
 427          void I2C_Read_Process(UINT8 u8DAT)
 428          {
 429   1          unsigned char  u8Count;
 430   1          /* Read Step1 */
 431   1          set_I2C0CON_STA;
 432   1          clr_I2C0CON_SI;          
 433   1          while (!(I2C0CON&SET_BIT3));                                //Check SI set or not
 434   1          if (I2C0STAT != 0x08)                         /*ÆðÊ¼Î»·¢ËÍ³É¹¦*///Check status value after every step
 435   1              I2C_Error();
 436   1      
 437   1          /* Step13 */
 438   1          clr_I2C0CON_STA;                                    //STA needs to be cleared after START codition is 
             -generated
 439   1          I2C0DAT = (I2C_SLAVE_ADDRESS | I2C_RD);       /*·¢ËÍ´Ó»úµØÖ·£¬ºÍ¶Á±êÖ¾Î»*/
 440   1          clr_I2C0CON_SI;
 441   1          while (!(I2C0CON&SET_BIT3));                                //Check SI set or not
 442   1        if (I2C0STAT != 0x40)                         /*·¢ËÍ³É¹¦ÊÕµ½´Ó»úÓ¦´ð*/
 443   1              I2C_Error();
 444   1          
 445   1          /* Step14 */
 446   1          for (u8Count = 0; u8Count <LOOP_SIZE; u8Count++)
 447   1          {
 448   2              set_I2C0CON_AA;
 449   2              clr_I2C0CON_SI;        
 450   2              while (!(I2C0CON&SET_BIT3));                            //Check SI set or not
 451   2      
 452   2              if (I2C0STAT != 0x50)              
 453   2                  I2C_Error();
 454   2              
 455   2              if (I2C0DAT != u8DAT)             
 456   2                  I2C_Error();
 457   2              u8DAT = ~u8DAT; 
 458   2          } 
 459   1          
 460   1          /* Step15 */
 461   1          clr_I2C0CON_AA;
 462   1          clr_I2C0CON_SI;
 463   1          while (!(I2C0CON&SET_BIT3));                                //Check SI set or not
 464   1          if (I2C0STAT != 0x58)
 465   1              I2C_Error();
 466   1      
 467   1          /* Step16 */
 468   1          set_I2C0CON_STO;
 469   1          clr_I2C0CON_SI;
 470   1          while (I2C0CON&SET_BIT4);                                /* Check STOP signal */ 
 471   1      }
C51 COMPILER V9.60.0.0   SHTC3                                                             10/31/2022 08:45:43 PAGE 9   

 472          //========================================================================================================
 473          
 474          uint16_t Get_TempValue(void)
 475          {
 476   1        return JBE.Temp_value;
 477   1      }
 478          
 479          
 480          uint16_t Get_TempValueMid(void)
 481          {
 482   1        return JBE.Temp_value_mid;
 483   1      }
 484          
 485          uint16_t Get_TempValueInit(void)
 486          {
 487   1        return JBE.Temp_value_Intinal;
 488   1      }
 489          
 490          
 491          
 492          uint16_t Get_Hub_value_Mid(void)
 493          {
 494   1        return JBE.Hub_value_mid;
 495   1      }
 496          
 497          uint16_t Get_Hub_value_Inti(void)
 498          {
 499   1        return JBE.Hub_value_Intinal;
 500   1      }
 501          
 502          
 503          
 504          
 505          
 506          
 507          
 508          
 509          
 510          
 511          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3368    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     26       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
