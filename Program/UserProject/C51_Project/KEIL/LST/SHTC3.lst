C51 COMPILER V9.60.0.0   SHTC3                                                             11/01/2022 15:53:28 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE SHTC3
OBJECT MODULE PLACED IN .\Output\SHTC3.obj
COMPILER INVOKED BY: d:\Keil_v5\C51\BIN\C51.EXE ..\..\..\UserCode\User\src\SHTC3.c LARGE OPTIMIZE(7,SPEED) BROWSE INCDIR
                    -(..\..\..\UserCode\Device\Include;..\..\..\UserCode\StdDriver\inc;..\..\..\UserCode\User\ins;..\..\..\UserCode\StdDriver
                    -\src;..\..\..\UserCode\StdDriver\lib) DEBUG OBJECTEXTEND PRINT(.\LST\SHTC3.lst) TABS(2) OBJECT(.\Output\SHTC3.obj)

line level    source

   1          #include "ML51.h"
   2          
   3          typedef enum SHTC3_Sta_s  //???????
   4          {
   5             Sleep,
   6             Wakeup,
   7             Mesured,
   8             Readstart,
   9             Readover,
  10          }SHTC3_Sta_s;
  11          
  12          typedef struct SHTC3_Data_t
  13          {
  14           uint8_t CmdBuf [2];
  15           uint8_t ReadBuf[6];
  16           SHTC3_Sta_s  SHTC3_Sta;
  17           uint16_t Temp_value;
  18           uint16_t Temp_value_mid; 
  19           uint16_t Hub_value;
  20           uint8_t crc8;  
  21           uint8_t OverTimeStartCount;  //¿ªÊ¼¼ì²âÊÇ·ñ³¬Ê±
  22           uint8_t TimeIsOver;
  23           uint8_t ThisPositiveTemp;
  24          }SHTC3_Data_t;
  25          
  26          SHTC3_Data_t SHTC3_Data;
  27          #define JBE SHTC3_Data
  28          
  29          void Init_SHTC3(void)
  30          {
  31   1      JBE.SHTC3_Sta=Sleep;
  32   1      }
  33          //========================================================================================================
  34          
  35          
  36          //========================================================================================================
  37          void I2C_Error(void)
  38          {
  39   1         // while (1);    
  40   1        //Get_TempHut();
  41   1      }
  42          //========================================================================================================
  43          
  44          //--------------------------------------------------------------------------------------------
  45          
  46          //--------------------------------------------------------------------------------------------
  47          /*Ö÷»ú·¢ËÍÄ£Ê½*/
  48          void I2C_Write(UINT8 *pbuf,UINT8 len )
  49          {
  50   1           unsigned char  u8Count;
  51   1           
  52   1          /* Write Step1 */
  53   1          set_I2C0CON_STA;                                      /*STAÖÃ1Î»Ö÷»ú·¢ËÍÄ£Ê½£¬Ó²¼þ·¢³öÆðÊ¼ÐÅºÅ£¬Èç¹ûÆðÊ
C51 COMPILER V9.60.0.0   SHTC3                                                             11/01/2022 15:53:28 PAGE 2   

             -¼ÐÅºÅ·¢ËÍ³É¹¦£¬SI ÖÃ1*/                                /* Send Start bit to I2C EEPROM */
  54   1          clr_I2C0CON_SI;
  55   1          while (!(I2C0CON&SET_BIT3))//;                          /*SIÖÃ1ËµÃ÷ÆðÊ¼ÐÅºÅ·¢ËÍ³É¹¦*/                  
             -          /*Check SI set or not  */
  56   1           {
  57   2           JBE.OverTimeStartCount=True;    //¿ªÊ¼¼ì²âÊÇ·ñ³¬Ê±
  58   2           if(JBE.TimeIsOver==True)            //Èç¹û³¬Ê±ÁË
  59   2           {
  60   3            JBE.OverTimeStartCount=False;
  61   3            JBE.TimeIsOver=False;
  62   3            I2C_Error(); 
  63   3            return;      
  64   3           }
  65   2           }
  66   1           JBE.OverTimeStartCount=False;
  67   1           JBE.TimeIsOver=False;
  68   1          if (I2C0STAT != 0x08)                                 /*×´Ì¬ÂëÎª0x08µÄÊ±ºòËµÃ÷ÆðÊ¼ÐÅºÅ·¢ËÍ³É¹¦*/       
             -         /*Check status value after every step   */
  69   1              I2C_Error();
  70   1          /*·¢ËÍ´Ó»úµØÖ·ºÍÐ´±êÖ¾*/
  71   1          /* Write Step2 */
  72   1          clr_I2C0CON_STA;                                      /*STA=0*/
  73   1          I2C0DAT = (I2C_SLAVE_ADDRESS | I2C_WR);
  74   1          clr_I2C0CON_SI;
  75   1         // while (!(I2C0CON&SET_BIT3));                          /*Check SI set or not */
  76   1          while (!(I2C0CON&SET_BIT3))//;                          /*SIÖÃ1ËµÃ÷ÆðÊ¼ÐÅºÅ·¢ËÍ³É¹¦*/                   
             -         /*Check SI set or not  */
  77   1           {
  78   2           JBE.OverTimeStartCount=True;    //¿ªÊ¼¼ì²âÊÇ·ñ³¬Ê±
  79   2           if(JBE.TimeIsOver==True)            //Èç¹û³¬Ê±ÁË
  80   2           {
  81   3            JBE.OverTimeStartCount=False;
  82   3            JBE.TimeIsOver=False;
  83   3            I2C_Error(); 
  84   3            return;      
  85   3           }
  86   2           }
  87   1           JBE.OverTimeStartCount=False;
  88   1           JBE.TimeIsOver=False;
  89   1          if (I2C0STAT != 0x18)                                 /*´Ó»úµØÖ·ÒÑ·¢£¬ÊÕµ½ÁËÓ¦´ð£¬×´Ì¬Îª0x18*/
  90   1              I2C_Error();
  91   1      
  92   1          /* Write Step3 */
  93   1          for (u8Count = 0; u8Count < len; u8Count++)     /*Ñ­»··¢ËÍ×Ô¶¨ÒåÊý¾Ý*/
  94   1          {
  95   2             
  96   2              I2C0DAT = *pbuf;
  97   2              pbuf++;
  98   2              clr_I2C0CON_SI;
  99   2             // while (!(I2C0CON&SET_BIT3));                       /*Check SI set or not*/
 100   2                while (!(I2C0CON&SET_BIT3))//;                          /*SIÖÃ1ËµÃ÷ÆðÊ¼ÐÅºÅ·¢ËÍ³É¹¦*/              
             -              /*Check SI set or not  */
 101   2                 {
 102   3                 JBE.OverTimeStartCount=True;    //¿ªÊ¼¼ì²âÊÇ·ñ³¬Ê±
 103   3                 if(JBE.TimeIsOver==True)            //Èç¹û³¬Ê±ÁË
 104   3                 {
 105   4                  JBE.OverTimeStartCount=False;
 106   4                  JBE.TimeIsOver=False;
 107   4                  I2C_Error(); 
 108   4                  return;      
 109   4                 }
 110   3                 }
C51 COMPILER V9.60.0.0   SHTC3                                                             11/01/2022 15:53:28 PAGE 3   

 111   2                 JBE.OverTimeStartCount=False;
 112   2                 JBE.TimeIsOver=False;
 113   2              if (I2C0STAT != 0x28)
 114   2                  I2C_Error();
 115   2          }
 116   1      
 117   1          /* Write Step4 */
 118   1          set_I2C0CON_STO;    /*Í£Ö¹±êÖ¾Î»£¬Ö÷»úÄ£Ê½ÏÂÉèÖÃÎª1Ê±Ïò×ÜÏß·¢ËÍÍ£Ö¹ÐÅºÅ*/
 119   1          clr_I2C0CON_SI;
 120   1         // while (I2C0CON&SET_BIT4); 
 121   1            while (!(I2C0CON&SET_BIT4))//;                          /*SIÖÃ1ËµÃ÷ÆðÊ¼ÐÅºÅ·¢ËÍ³É¹¦*/                 
             -           /*Check SI set or not  */
 122   1                 {
 123   2                 JBE.OverTimeStartCount=True;    //¿ªÊ¼¼ì²âÊÇ·ñ³¬Ê±
 124   2                 if(JBE.TimeIsOver==True)            //Èç¹û³¬Ê±ÁË
 125   2                 {
 126   3                  JBE.OverTimeStartCount=False;
 127   3                  JBE.TimeIsOver=False;
 128   3                  I2C_Error(); 
 129   3                  return;      
 130   3                 }
 131   2                 }
 132   1                 JBE.OverTimeStartCount=False;
 133   1                 JBE.TimeIsOver=False;
 134   1      
 135   1      }
 136          
 137          void I2C_Read(UINT8 *pbuf,len)
 138          {
 139   1          unsigned char  u8Count;
 140   1          /* Read Step1 */
 141   1          set_I2C0CON_STA;
 142   1          clr_I2C0CON_SI;          
 143   1         // while (!(I2C0CON&SET_BIT3));                                //Check SI set or not
 144   1          while (!(I2C0CON&SET_BIT3))//;                          /*SIÖÃ1ËµÃ÷ÆðÊ¼ÐÅºÅ·¢ËÍ³É¹¦*/                  
             -          /*Check SI set or not  */
 145   1           {
 146   2           JBE.OverTimeStartCount=True;    //¿ªÊ¼¼ì²âÊÇ·ñ³¬Ê±
 147   2           if(JBE.TimeIsOver==True)            //Èç¹û³¬Ê±ÁË
 148   2           {
 149   3            JBE.OverTimeStartCount=False;
 150   3            JBE.TimeIsOver=False;
 151   3            I2C_Error(); 
 152   3            return;      
 153   3           }
 154   2           }
 155   1           JBE.OverTimeStartCount=False;
 156   1           JBE.TimeIsOver=False;
 157   1        if (I2C0STAT != 0x08)                         /*ÆðÊ¼Î»·¢ËÍ³É¹¦*///Check status value after every step
 158   1              I2C_Error();
 159   1      
 160   1          /* Step13 */
 161   1          clr_I2C0CON_STA;                                    //STA needs to be cleared after START codition is 
             -generated
 162   1          I2C0DAT = (I2C_SLAVE_ADDRESS | I2C_RD);       /*·¢ËÍ´Ó»úµØÖ·£¬ºÍ¶Á±êÖ¾Î»*/
 163   1          clr_I2C0CON_SI;
 164   1          //while (!(I2C0CON&SET_BIT3));                                //Check SI set or not
 165   1          while (!(I2C0CON&SET_BIT3))//;                          /*SIÖÃ1ËµÃ÷ÆðÊ¼ÐÅºÅ·¢ËÍ³É¹¦*/                  
             -          /*Check SI set or not  */
 166   1           {
 167   2           JBE.OverTimeStartCount=True;    //¿ªÊ¼¼ì²âÊÇ·ñ³¬Ê±
 168   2           if(JBE.TimeIsOver==True)            //Èç¹û³¬Ê±ÁË
C51 COMPILER V9.60.0.0   SHTC3                                                             11/01/2022 15:53:28 PAGE 4   

 169   2           {
 170   3            JBE.OverTimeStartCount=False;
 171   3            JBE.TimeIsOver=False;
 172   3            I2C_Error(); 
 173   3            return;      
 174   3           }
 175   2           }
 176   1           JBE.OverTimeStartCount=False;
 177   1           JBE.TimeIsOver=False;
 178   1        if (I2C0STAT != 0x40)                         /*·¢ËÍ³É¹¦ÊÕµ½´Ó»úÓ¦´ð*/
 179   1              I2C_Error();
 180   1          
 181   1          /* Step14 */
 182   1          for (u8Count = 0; u8Count <len; u8Count++)
 183   1          {
 184   2              set_I2C0CON_AA;
 185   2              clr_I2C0CON_SI;        
 186   2             //while (!(I2C0CON&SET_BIT3));                            //Check SI set or not
 187   2               while (!(I2C0CON&SET_BIT3))//;                          /*SIÖÃ1ËµÃ÷ÆðÊ¼ÐÅºÅ·¢ËÍ³É¹¦*/            
             -                /*Check SI set or not  */
 188   2                 {
 189   3                 JBE.OverTimeStartCount=True;    //¿ªÊ¼¼ì²âÊÇ·ñ³¬Ê±
 190   3                 if(JBE.TimeIsOver==True)            //Èç¹û³¬Ê±ÁË
 191   3                 {
 192   4                  JBE.OverTimeStartCount=False;
 193   4                  JBE.TimeIsOver=False;
 194   4                  I2C_Error(); 
 195   4                  return;      
 196   4                 }
 197   3                 }
 198   2                 JBE.OverTimeStartCount=False;
 199   2                 JBE.TimeIsOver=False;
 200   2              if (I2C0STAT != 0x50)              
 201   2                  I2C_Error();
 202   2              
 203   2              // if (I2C0DAT != u8DAT)             
 204   2              //    I2C_Error();
 205   2              *pbuf=I2C0DAT;
 206   2               pbuf++;
 207   2          } 
 208   1          
 209   1          /* Step15 */
 210   1          clr_I2C0CON_AA;
 211   1          clr_I2C0CON_SI;
 212   1          //while (!(I2C0CON&SET_BIT3));                                //Check SI set or not
 213   1            while (!(I2C0CON&SET_BIT3))//;                          /*SIÖÃ1ËµÃ÷ÆðÊ¼ÐÅºÅ·¢ËÍ³É¹¦*/                 
             -           /*Check SI set or not  */
 214   1                 {
 215   2                 JBE.OverTimeStartCount=True;    //¿ªÊ¼¼ì²âÊÇ·ñ³¬Ê±
 216   2                 if(JBE.TimeIsOver==True)            //Èç¹û³¬Ê±ÁË
 217   2                 {
 218   3                  JBE.OverTimeStartCount=False;
 219   3                  JBE.TimeIsOver=False;
 220   3                  I2C_Error(); 
 221   3                  return;      
 222   3                 }
 223   2                 }
 224   1                 JBE.OverTimeStartCount=False;
 225   1                 JBE.TimeIsOver=False;
 226   1          if (I2C0STAT != 0x58)
 227   1              I2C_Error();
 228   1      
C51 COMPILER V9.60.0.0   SHTC3                                                             11/01/2022 15:53:28 PAGE 5   

 229   1          /* Step16 */
 230   1          set_I2C0CON_STO;
 231   1          clr_I2C0CON_SI;
 232   1         //while (I2C0CON&SET_BIT4);                                /* Check STOP signal */ 
 233   1            while (!(I2C0CON&SET_BIT4))//;                          /* SIÖÃ1ËµÃ÷ÆðÊ¼ÐÅºÅ·¢ËÍ³É¹¦*/                
             -            /*Check SI set or not  */
 234   1                 {
 235   2                 JBE.OverTimeStartCount=True;    //¿ªÊ¼¼ì²âÊÇ·ñ³¬Ê±
 236   2                 if(JBE.TimeIsOver==True)            //Èç¹û³¬Ê±ÁË
 237   2                 {
 238   3                  JBE.OverTimeStartCount=False;
 239   3                  JBE.TimeIsOver=False;
 240   3                  I2C_Error(); 
 241   3                  return;      
 242   3                 }
 243   2                 }
 244   1                 JBE.OverTimeStartCount=False;
 245   1                 JBE.TimeIsOver=False;
 246   1      }
 247          
 248          void Init_I2C(void)
 249          {
 250   1          MFP_P53_I2C0_SCL;
 251   1          P53_OPENDRAIN_MODE ;          // Modify SCL pin to Open drain mode. don't forget the pull high resiste
             -r in circuit
 252   1          MFP_P52_I2C0_SDA;
 253   1          P52_OPENDRAIN_MODE ;          // Modify SDA pin to Open drain mode. don't forget the pull high resiste
             -r in circuit
 254   1      
 255   1          SFRS = 0;
 256   1          /* Set I2C clock rate */
 257   1          I2C0CLK = I2C_CLOCK; 
 258   1      
 259   1          /* Enable I2C */
 260   1          set_I2C0CON_I2CEN;  
 261   1          JBE.SHTC3_Sta=Sleep;
 262   1          JBE.CmdBuf [0]=0x35;     //Ë¯ÃßÄ£Ê½ÏÂ·¢ËÍ»½ÐÑÃüÁî0x3517                                                 
             -                                                                                                                  
 263   1          JBE.CmdBuf [1]=0x17;
 264   1          I2C_Write(&JBE.CmdBuf,sizeof(JBE.CmdBuf));
 265   1          JBE.CmdBuf [0]=0x80;                                                                                  
             -                                                                                   
 266   1          JBE.CmdBuf [1]=0x5D;
 267   1          I2C_Write(&JBE.CmdBuf,sizeof(JBE.CmdBuf));  
 268   1      }
 269          
 270          
 271          void Get_TempHut(void)
 272          {
 273   1       #ifdef test
                
                JBE.CmdBuf [0]=0x35;     //Ë¯ÃßÄ£Ê½ÏÂ·¢ËÍ»½ÐÑÃüÁî0x3517                                                  
             -                                                                                                                 
                JBE.CmdBuf [1]=0x17;
                I2C_Write(&JBE.CmdBuf,sizeof(JBE.CmdBuf));
                
                JBE.CmdBuf [0]=0xEF;     //·¢ËÍ¶ÁÈ¡IDµÄÃüÁî0xEFC8   ²âÊÔi2cµÄÍ¨ÐÅ                                        
             -                                                                                                                   
                JBE.CmdBuf [1]=0xC8;
                I2C_Write(&JBE.CmdBuf,sizeof(JBE.CmdBuf));
                I2C_Read(&JBE.ReadBuf,3);
              //  printf("\n READ ID!");
C51 COMPILER V9.60.0.0   SHTC3                                                             11/01/2022 15:53:28 PAGE 6   

                
               #else  
 286   1       if(JBE.SHTC3_Sta==Sleep)
 287   1       {
 288   2        JBE.CmdBuf [0]=0x35;     //Ë¯ÃßÄ£Ê½ÏÂ·¢ËÍ»½ÐÑÃüÁî0x3517                                                  
             -                                                                                                                 
 289   2        JBE.CmdBuf [1]=0x17;
 290   2        I2C_Write(&JBE.CmdBuf,sizeof(JBE.CmdBuf));
 291   2        JBE.SHTC3_Sta=Wakeup;
 292   2       }
 293   1       else if(JBE.SHTC3_Sta== Wakeup)
 294   1       {
 295   2        JBE.CmdBuf [0]=0x7c;     //»½ÐÑÒÔºó·¢ËÍ0x7CA2Ñ¡ÔñÆÕÍ¨Ä£Ê½£¬¸ß¾«¶È¶ÁÈ¡
 296   2        JBE.CmdBuf [1]=0xa2;
 297   2        I2C_Write(&JBE.CmdBuf,sizeof(JBE.CmdBuf));
 298   2        JBE.SHTC3_Sta=Mesured;
 299   2       }
 300   1       else if(JBE.SHTC3_Sta== Mesured)
 301   1       {
 302   2         static unsigned char  DelayTime;
 303   2         DelayTime++;
 304   2         if(DelayTime>MeasurDlayTime)
 305   2         {
 306   3         DelayTime=0;
 307   3         JBE.SHTC3_Sta=Readstart;
 308   3         }
 309   2       }
 310   1       else if(JBE.SHTC3_Sta== Readstart)
 311   1       {
 312   2         I2C_Read(&JBE.ReadBuf,sizeof(JBE.ReadBuf));
 313   2         JBE.SHTC3_Sta=Readover; 
 314   2          JBE.crc8=crc8_nrsc5(&JBE.ReadBuf[0],2);
 315   2          JBE.crc8=crc8_nrsc5(&JBE.ReadBuf[3],2);
 316   2         if(crc8_nrsc5(&JBE.ReadBuf[0],2)==JBE.ReadBuf[2]&&crc8_nrsc5(&JBE.ReadBuf[3],2)==JBE.ReadBuf[5])
 317   2         {
 318   3         JBE.Temp_value_mid=JBE.ReadBuf[0];
 319   3         JBE.Temp_value_mid=JBE.Temp_value_mid<<8;
 320   3         JBE.Temp_value_mid=JBE.Temp_value_mid+JBE.ReadBuf[1];
 321   3         
 322   3         
 323   3         JBE.Temp_value_mid=(float)JBE.Temp_value_mid/65536*175*10-15;
 324   3         //JBE.Temp_value_mid=234; 
 325   3         if(JBE.Temp_value_mid>=450)                                  //ËµÃ÷»ñµÃµÄÊÇÕýÎÂ¶È
 326   3         {
 327   4         JBE.Temp_value_mid=JBE.Temp_value_mid-450;    
 328   4         JBE.ThisPositiveTemp=True;
 329   4         }
 330   3         else 
 331   3         {
 332   4         JBE.Temp_value_mid=450-JBE.Temp_value_mid;
 333   4         JBE.ThisPositiveTemp=False;
 334   4         }
 335   3         
 336   3         JBE.Temp_value=JBE.Temp_value_mid;//(JBE.Temp_value_mid-((GET_NtcTEMP()+5-JBE.Temp_value_mid)));
 337   3           
 338   3         JBE.Hub_value=JBE.ReadBuf[3];
 339   3         JBE.Hub_value=JBE.Hub_value<<8;
 340   3         JBE.Hub_value=JBE.Hub_value+JBE.ReadBuf[4];
 341   3         JBE.Hub_value=(float)JBE.Hub_value/65536*100+10;  
 342   3         }
 343   2        
 344   2         //LCD_Display_TempHub(JBE.Hub_value,HUB);
C51 COMPILER V9.60.0.0   SHTC3                                                             11/01/2022 15:53:28 PAGE 7   

 345   2       }
 346   1       else if(JBE.SHTC3_Sta== Readover)
 347   1       {
 348   2        JBE.CmdBuf [0]=0xB0;
 349   2        JBE.CmdBuf [1]=0x98;
 350   2        I2C_Write(&JBE.CmdBuf,sizeof(JBE.CmdBuf));
 351   2        JBE.SHTC3_Sta=Sleep;
 352   2        Clr__TempHutStartFlag();            //ÎÂÊª¶È²âÁ¿Æô¶¯±êÖ¾ÇåÁã£¬µÈ´ýÏÂÒ»Ãë¿ªÆô
 353   2       }
 354   1       #endif
 355   1       
 356   1      }
 357          void I2C_Write_Process(UINT8 u8DAT)
 358          {
 359   1          unsigned char  u8Count;
 360   1          /* Write Step1 */
 361   1          set_I2C0CON_STA;                                      /*STAÖÃ1Î»Ö÷»ú·¢ËÍÄ£Ê½£¬Ó²¼þ·¢³öÆðÊ¼ÐÅºÅ£¬Èç¹ûÆðÊ
             -¼ÐÅºÅ·¢ËÍ³É¹¦£¬SI ÖÃ1*/                                /* Send Start bit to I2C EEPROM */
 362   1          clr_I2C0CON_SI;
 363   1          while (!(I2C0CON&SET_BIT3));                          /*SIÖÃ1ËµÃ÷ÆðÊ¼ÐÅºÅ·¢ËÍ³É¹¦*/                    
             -        /*Check SI set or not  */
 364   1          if (I2C0STAT != 0x08)                                 /*×´Ì¬ÂëÎª0x08µÄÊ±ºòËµÃ÷ÆðÊ¼ÐÅºÅ·¢ËÍ³É¹¦*/       
             -         /*Check status value after every step   */
 365   1              I2C_Error();
 366   1          /*·¢ËÍ´Ó»úµØÖ·ºÍÐ´±êÖ¾*/
 367   1          /* Write Step2 */
 368   1          clr_I2C0CON_STA;                                      /*STA=0*/
 369   1          I2C0DAT = (I2C_SLAVE_ADDRESS | I2C_WR);
 370   1          clr_I2C0CON_SI;
 371   1          while (!(I2C0CON&SET_BIT3));                          /*Check SI set or not */
 372   1          if (I2C0STAT != 0x18)                                 /*´Ó»úµØÖ·ÒÑ·¢£¬ÊÕµ½ÁËÓ¦´ð£¬×´Ì¬Îª0x18*/
 373   1              I2C_Error();
 374   1      
 375   1          /* Write Step3 */
 376   1          for (u8Count = 0; u8Count < LOOP_SIZE; u8Count++)     /*Ñ­»··¢ËÍ×Ô¶¨ÒåÊý¾Ý*/
 377   1          {
 378   2              I2C0DAT = u8DAT;
 379   2              clr_I2C0CON_SI;
 380   2              while (!(I2C0CON&SET_BIT3));                       /*Check SI set or not*/
 381   2              if (I2C0STAT != 0x28)
 382   2                  I2C_Error();
 383   2      
 384   2              u8DAT = ~u8DAT;
 385   2          }
 386   1      
 387   1          /* Write Step4 */
 388   1          set_I2C0CON_STO;    /*Í£Ö¹±êÖ¾Î»£¬Ö÷»úÄ£Ê½ÏÂÉèÖÃÎª1Ê±Ïò×ÜÏß·¢ËÍÍ£Ö¹ÐÅºÅ*/
 389   1          clr_I2C0CON_SI;
 390   1          while (I2C0CON&SET_BIT4);                               /* Check STOP signal */
 391   1      }
 392            
 393          //--------------------------------------------------------------------------------------------
 394          //----  Page Read ----------------------------------------------------------------------------
 395          //--------------------------------------------------------------------------------------------
 396          void I2C_Read_Process(UINT8 u8DAT)
 397          {
 398   1          unsigned char  u8Count;
 399   1          /* Read Step1 */
 400   1          set_I2C0CON_STA;
 401   1          clr_I2C0CON_SI;          
 402   1          while (!(I2C0CON&SET_BIT3));                                //Check SI set or not
 403   1          if (I2C0STAT != 0x08)                         /*ÆðÊ¼Î»·¢ËÍ³É¹¦*///Check status value after every step
C51 COMPILER V9.60.0.0   SHTC3                                                             11/01/2022 15:53:28 PAGE 8   

 404   1              I2C_Error();
 405   1      
 406   1          /* Step13 */
 407   1          clr_I2C0CON_STA;                                    //STA needs to be cleared after START codition is 
             -generated
 408   1          I2C0DAT = (I2C_SLAVE_ADDRESS | I2C_RD);       /*·¢ËÍ´Ó»úµØÖ·£¬ºÍ¶Á±êÖ¾Î»*/
 409   1          clr_I2C0CON_SI;
 410   1          while (!(I2C0CON&SET_BIT3));                                //Check SI set or not
 411   1        if (I2C0STAT != 0x40)                         /*·¢ËÍ³É¹¦ÊÕµ½´Ó»úÓ¦´ð*/
 412   1              I2C_Error();
 413   1          
 414   1          /* Step14 */
 415   1          for (u8Count = 0; u8Count <LOOP_SIZE; u8Count++)
 416   1          {
 417   2              set_I2C0CON_AA;
 418   2              clr_I2C0CON_SI;        
 419   2              while (!(I2C0CON&SET_BIT3));                            //Check SI set or not
 420   2      
 421   2              if (I2C0STAT != 0x50)              
 422   2                  I2C_Error();
 423   2              
 424   2              if (I2C0DAT != u8DAT)             
 425   2                  I2C_Error();
 426   2              u8DAT = ~u8DAT; 
 427   2          } 
 428   1          
 429   1          /* Step15 */
 430   1          clr_I2C0CON_AA;
 431   1          clr_I2C0CON_SI;
 432   1          while (!(I2C0CON&SET_BIT3));                                //Check SI set or not
 433   1          if (I2C0STAT != 0x58)
 434   1              I2C_Error();
 435   1      
 436   1          /* Step16 */
 437   1          set_I2C0CON_STO;
 438   1          clr_I2C0CON_SI;
 439   1          while (I2C0CON&SET_BIT4);                                /* Check STOP signal */ 
 440   1      }
 441          //========================================================================================================
 442          
 443          uint16_t Get_TempValue(void)
 444          {
 445   1        return JBE.Temp_value;
 446   1      }
 447          
 448          uint16_t Get_HubValue(void)
 449          {
 450   1        return JBE.Hub_value;
 451   1      }
 452          
 453          void Is_IIC_OverTime(void)
 454          {
 455   1       static uint8_t countT=0;
 456   1       if(JBE.OverTimeStartCount==True) //¿ªÊ¼¼ÆÊý
 457   1       {
 458   2       countT++;
 459   2       if(countT>10)                    //µÈ´ý³¬³ö10ms
 460   2       {
 461   3       JBE.TimeIsOver=True;              //ÒÑ³¬Ê±
 462   3       countT=0; 
 463   3       }
 464   2         
C51 COMPILER V9.60.0.0   SHTC3                                                             11/01/2022 15:53:28 PAGE 9   

 465   2       }
 466   1      
 467   1      }
 468          
 469          uint8_t Get_TempPositive(void)
 470          {
 471   1      return JBE.ThisPositiveTemp;
 472   1      }
 473          
 474          void Set_TempPositive(void)
 475          {
 476   1      JBE.ThisPositiveTemp=True;
 477   1      }
 478          
 479          
 480          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1377    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     21       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
