C51 COMPILER V9.60.0.0   ADC_USER                                                          11/01/2022 15:53:28 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE ADC_USER
OBJECT MODULE PLACED IN .\Output\ADC_USER.obj
COMPILER INVOKED BY: d:\Keil_v5\C51\BIN\C51.EXE ..\..\..\UserCode\User\src\ADC_USER.c LARGE OPTIMIZE(7,SPEED) BROWSE INC
                    -DIR(..\..\..\UserCode\Device\Include;..\..\..\UserCode\StdDriver\inc;..\..\..\UserCode\User\ins;..\..\..\UserCode\StdDri
                    -ver\src;..\..\..\UserCode\StdDriver\lib) DEBUG OBJECTEXTEND PRINT(.\LST\ADC_USER.lst) TABS(2) OBJECT(.\Output\ADC_USER.o
                    -bj)

line level    source

   1          #include "ML51.h"
   2          /*NTC???????*/
   3          const unsigned int  NTC_ADCValue[81]={
   4                                               3950,3890,3829,3766,3703,3638,3572,3506,3439,3371,
   5                                               3302,3233,3164,3094,3024,2954,2884,2814,2745,2676,
   6                                               2607,2539,2471,2403,2337,2272,2207,2144,2081,2019,
   7                                               1959,1899,1841,1784,1728,1674,1620,1569,1518,1469,
   8                                               1421,1374,1328,1284,1241,1200,1159,1120,1082,1046,
   9                                               1010, 976, 941, 910, 879, 848, 820, 791, 764, 737,
  10                                                712, 687, 664, 641, 619, 599, 578, 558, 539, 521,
  11                                                503, 486, 470, 454, 438, 424, 410, 396, 383, 370,
  12                                                357 
  13                                              } ;
  14          
  15          typedef struct NTC_Data_s
  16          {
  17            uint16_t Min_NTC_Val;          //NTC????
  18            uint16_t Max_NTC_Val;          //NTC??§³?
  19            uint16_t NTC_Val_Sum;          //NTC16?¦Å??????
  20            uint16_t NTC_Val;              //NTC???????
  21            uint16_t NTC_Val_Last;         //NTC????¦Å?????
  22            uint16_t Adval_Ntc[18];        //NTC??????›¥????
  23            uint8_t  Adval_Ntc_Idx;        //NTC?????¡À?
  24            uint16_t NTC_Temp;             //NTC????
  25            uint16_t NTC_Init;             //NTC????
  26            uint8_t NTC_Temp_i;
  27            uint8_t IsFistGetTemp;
  28          }NTC_Data_s;
  29          
  30          typedef struct Bat_Data_s
  31          {
  32            uint16_t Min_Bat_Val;          //Bat????
  33            uint16_t Max_Bat_Val;          //Bat??§³?
  34            uint32_t Bat_Val_Sum;          //Bat16?¦Å??????
  35            uint16_t Bat_Val;              //Bat???????
  36            uint16_t Bat_Val_Last;         //Bat????¦Å?????
  37            uint16_t Adval_Bat[18];        //Bat??????›¥????
  38            uint8_t  Adval_Bat_Idx;        //Bat?????¡À?
  39            uint32_t Bat_Voltage;          //Bat????
  40            uint8_t  IsNeedCheckBatvolt;   //?????????????
  41            BatMod_s BatMod;               //?????
  42            uint8_t  BatPowerPecent;       //????????
  43            //uint16_t NTC_Init;             Bat????
  44            //uint8_t NTC_Temp_i;
  45            //uint8_t IsFistGetTemp;
  46          }Bat_Data_s;
  47          
  48          typedef struct ADC_Data_s
  49          {
  50          NTC_Data_s NTC_Data;
  51          Bat_Data_s Bat_Data;  
  52          uint8_t Is_Bat_ChargFull;
C51 COMPILER V9.60.0.0   ADC_USER                                                          11/01/2022 15:53:28 PAGE 2   

  53          }ADC_Data_s;
  54          
  55          ADC_Data_s ADC_Data;
  56          #define JBE ADC_Data
  57            
  58          void ADC_Init(void)
  59          {
  60   1      ENABLE_ADC_CH4; 
  61   1      ADC_Open(ADC_SINGLE,ADC_CHANNEL_4 );     //????????????4?????
  62   1      ADC_SamplingTime(3,7);                   //???¨°??????
  63   1      ADC_Vref_Set(Enable,Enable,Level_2_560V);//?????????????????
  64   1      clr_ADCCON0_ADCF;                        //????????¦Ë????
  65   1      GPIO_SetMode(BatVoltCheck_PORT ,BatVoltCheck_PIN,GPIO_MODE_PUSHPULL); 
  66   1      P24_QUASI_MODE;                          //P2.4????????????????????§Ô??
  67   1      //GPIO_SetMode(Port5 ,BIT1,GPIO_MODE_PUSHPULL);
  68   1      //BAT_TEST_ON();
  69   1      GPIO_SetMode(Port4 ,BIT2,GPIO_MODE_PUSHPULL); 
  70   1      //ENABLE_P63_PULLUP;
  71   1      BAT_POWER_ON();
  72   1      BatVoltCheck_ON;
  73   1      JBE.NTC_Data.IsFistGetTemp=True;  
  74   1      JBE.Bat_Data.IsNeedCheckBatvolt=False;
  75   1      }
  76          
  77          uint32_t Get_NtcValu(void)
  78          {  
  79   1          uint32_t ADCdataAIN;
  80   1          uint32_t Ntc_valu;
  81   1          clr_ADCCON0_ADCF;
  82   1          set_ADCCON0_ADCS;                  // ADC start trig signal
  83   1          while(!(ADCCON0&SET_BIT7));
  84   1          ADCdataAIN = (ADCRH<<4)|ADCRL;
  85   1          JBE.NTC_Data.Adval_Ntc[JBE.NTC_Data.Adval_Ntc_Idx]= ADCdataAIN;
  86   1          JBE.NTC_Data.Adval_Ntc_Idx++;
  87   1          Ntc_valu=ADCdataAIN;
  88   1          clr_ADCCON0_ADCF;
  89   1          clr_ADCCON0_ADCS;
  90   1          return Ntc_valu;
  91   1      }
  92          
  93          void ADC_RUN(uint8_t Channel)
  94          {
  95   1          uint32_t ADCdataAIN;
  96   1          if(Channel==Channel_Temp)
  97   1          {
  98   2          ENABLE_ADC_CH4; 
  99   2          clr_ADCCON0_ADCF;
 100   2          set_ADCCON0_ADCS;                  // ADC start trig signal
 101   2          while(!(ADCCON0&SET_BIT7));
 102   2          ADCdataAIN = (ADCRH<<4)|ADCRL;
 103   2          JBE.NTC_Data.Adval_Ntc[JBE.NTC_Data.Adval_Ntc_Idx]= ADCdataAIN;
 104   2          JBE.NTC_Data.Adval_Ntc_Idx++;
 105   2          clr_ADCCON0_ADCF;
 106   2          clr_ADCCON0_ADCS;
 107   2          }
 108   1          else if(Channel==Channel_BatVolt)
 109   1          {
 110   2          ENABLE_ADC_CH0; 
 111   2          clr_ADCCON0_ADCF;
 112   2          set_ADCCON0_ADCS;                  // ADC start trig signal
 113   2          while(!(ADCCON0&SET_BIT7));
 114   2          ADCdataAIN = (ADCRH<<4)|ADCRL;
C51 COMPILER V9.60.0.0   ADC_USER                                                          11/01/2022 15:53:28 PAGE 3   

 115   2          JBE.Bat_Data.Adval_Bat[JBE.Bat_Data.Adval_Bat_Idx]= ADCdataAIN;
 116   2          JBE.Bat_Data.Adval_Bat_Idx++;
 117   2          clr_ADCCON0_ADCF;
 118   2          clr_ADCCON0_ADCS;
 119   2          }
 120   1          
 121   1      }
 122          
 123          void Get_Temp_Bat(uint8_t Channel)
 124          {
 125   1         uint8_t i;
 126   1         switch (Channel)
 127   1         {
 128   2           case Channel_Temp:
 129   2           {
 130   3             ADC_RUN(Channel_Temp);
 131   3             if(JBE.NTC_Data.Adval_Ntc_Idx>=18)
 132   3             {
 133   4             JBE.NTC_Data.Adval_Ntc_Idx=0;
 134   4             JBE.NTC_Data.Min_NTC_Val=JBE.NTC_Data.Adval_Ntc[0]; //???????§³??????
 135   4             JBE.NTC_Data.Max_NTC_Val=JBE.NTC_Data.Adval_Ntc[0]; 
 136   4             JBE.NTC_Data.NTC_Val_Sum=0;                //????????????
 137   4             for(i= 1;i<18;i++)              //????????§³?
 138   4             {
 139   5              if(JBE.NTC_Data.Max_NTC_Val<JBE.NTC_Data.Adval_Ntc[i])
 140   5                 JBE.NTC_Data.Max_NTC_Val=JBE.NTC_Data.Adval_Ntc[i];
 141   5              if(JBE.NTC_Data.Min_NTC_Val>JBE.NTC_Data.Adval_Ntc[i])
 142   5                 JBE.NTC_Data.Min_NTC_Val=JBE.NTC_Data.Adval_Ntc[i];        
 143   5             }
 144   4              for(i= 0;i< 18;i++)     //???
 145   4              {
 146   5                JBE.NTC_Data.NTC_Val_Sum+=JBE.NTC_Data.Adval_Ntc[i];    
 147   5              }
 148   4              JBE.NTC_Data.NTC_Val_Sum =JBE.NTC_Data.NTC_Val_Sum -JBE.NTC_Data.Min_NTC_Val -JBE.NTC_Data.Max_NTC_Val
             -;            //????????§³?
 149   4              JBE.NTC_Data.NTC_Val_Sum>>= 4;                                                          //???????????????¦Ë
             -?????????4
 150   4              JBE.NTC_Data.NTC_Val=JBE.NTC_Data.NTC_Val_Sum;
 151   4              JBE.NTC_Data.NTC_Val=0.9*JBE.NTC_Data.NTC_Val_Sum+0.1*JBE.NTC_Data.NTC_Val_Last;
 152   4              JBE.NTC_Data.NTC_Val_Last=JBE.NTC_Data.NTC_Val; 
 153   4              for(i=0;i<80;i++)                                                            //?????????
 154   4              {
 155   5              if((JBE.NTC_Data.NTC_Val<=NTC_ADCValue[i])&&(JBE.NTC_Data.NTC_Val>NTC_ADCValue[i+1]))           //????
             -???¦¶
 156   5              {
 157   6               if(i<20)                                                                     //??????
 158   6               {
 159   7                JBE.NTC_Data.NTC_Temp=(19-i)*10+10*(NTC_ADCValue[i]-JBE.NTC_Data.NTC_Val)/(NTC_ADCValue[i]-NTC_ADCVal
             -ue[i+1]);
 160   7                
 161   7               }
 162   6               else                                                                         //???????
 163   6               {
 164   7               JBE.NTC_Data.NTC_Temp=(i-20)*10+(10*(NTC_ADCValue[i]-JBE.NTC_Data.NTC_Val))/(NTC_ADCValue[i]-NTC_ADCV
             -alue[i+1]);
 165   7               JBE.NTC_Data.NTC_Temp_i=i;
 166   7               JBE.NTC_Data.NTC_Temp_i=i;
 167   7               return; 
 168   7               }
 169   6              }
 170   5             } 
 171   4           }
C51 COMPILER V9.60.0.0   ADC_USER                                                          11/01/2022 15:53:28 PAGE 4   

 172   3           break;
 173   3           }
 174   2           case  Channel_BatVolt:
 175   2           {   
 176   3               uint8_t i;
 177   3              ADC_RUN(Channel_BatVolt);
 178   3             if(JBE.Bat_Data.Adval_Bat_Idx>=18)
 179   3             {
 180   4             JBE.Bat_Data.Adval_Bat_Idx=0;
 181   4             JBE.Bat_Data.Min_Bat_Val=JBE.Bat_Data.Adval_Bat[0]; //???????§³??????
 182   4             JBE.Bat_Data.Max_Bat_Val=JBE.Bat_Data.Adval_Bat[0]; 
 183   4             JBE.Bat_Data.Bat_Val_Sum=0;                //????????????
 184   4             for(i= 1;i<18;i++)              //????????§³?
 185   4             {
 186   5              if(JBE.Bat_Data.Max_Bat_Val<JBE.Bat_Data.Adval_Bat[i])
 187   5                 JBE.Bat_Data.Max_Bat_Val=JBE.Bat_Data.Adval_Bat[i];
 188   5              if(JBE.Bat_Data.Min_Bat_Val>JBE.Bat_Data.Adval_Bat[i])
 189   5                 JBE.Bat_Data.Min_Bat_Val=JBE.Bat_Data.Adval_Bat[i];        
 190   5             }
 191   4              for(i= 0;i< 18;i++)     //???
 192   4              {
 193   5                JBE.Bat_Data.Bat_Val_Sum+=JBE.Bat_Data.Adval_Bat[i];    
 194   5              }
 195   4              JBE.Bat_Data.Bat_Val_Sum =JBE.Bat_Data.Bat_Val_Sum -JBE.Bat_Data.Min_Bat_Val -JBE.Bat_Data.Max_Bat_Val
             -;            //????????§³?
 196   4              JBE.Bat_Data.Bat_Val_Sum>>= 4;                                                                             
             -       //???????????????¦Ë?????????4
 197   4              //JBE.Bat_Data.Bat_Val=JBE.Bat_Data.Bat_Val_Sum;
 198   4              JBE.Bat_Data.Bat_Val_Sum=0.9*JBE.Bat_Data.Bat_Val_Sum+0.1*JBE.Bat_Data.Bat_Val_Last;
 199   4              JBE.Bat_Data.Bat_Val_Last=JBE.Bat_Data.Bat_Val_Sum; 
 200   4              JBE.Bat_Data.Bat_Val=JBE.Bat_Data.Bat_Val_Sum*256*20/4095;
 201   4              
 202   4              
 203   4           }
 204   3           break;
 205   3           
 206   3           
 207   3           }
 208   2         
 209   2         
 210   2         }
 211   1      
 212   1        
 213   1      
 214   1      }
 215          
 216          void Bat_PowerDisplay(void)
 217          {  
 218   1         static uint16_t lowpowertime=0;
 219   1        if(IsChargOn==True)          //?????????
 220   1        {
 221   2         LCD_SetOnePixel(1, 22, Enable);  //?????????
 222   2         LCD_SetOnePixel(3, 23, Enable);
 223   2         if(JBE.Bat_Data.Bat_Val>4100)   //???????4v?????????
 224   2         {
 225   3          JBE.Is_Bat_ChargFull=True;
 226   3          LCD_SetOnePixel(0, 22, Enable); 
 227   3          LCD_SetOnePixel(0, 23, Enable);
 228   3          LCD_SetOnePixel(1, 23, Enable);
 229   3          LCD_SetOnePixel(2, 23, Enable); 
 230   3         
 231   3         }
C51 COMPILER V9.60.0.0   ADC_USER                                                          11/01/2022 15:53:28 PAGE 5   

 232   2         /*???????1.??§Ô??????????§³??4.1v?????????.2.?????????¦Å?????????????????3.9v???????????*/
 233   2         else if((JBE.Bat_Data.Bat_Val<4100&&JBE.Is_Bat_ChargFull==False)||(JBE.Bat_Data.Bat_Val<3900&&JBE.Is_Bat
             -_ChargFull==True))
 234   2         {
 235   3         lowpowertime++;
 236   3         if(lowpowertime==1)
 237   3         {
 238   4          LCD_SetOnePixel(0, 22, Enable);
 239   4          LCD_SetOnePixel(0, 23, Enable);
 240   4          LCD_SetOnePixel(2, 23, Disable);
 241   4          LCD_SetOnePixel(1, 23, Disable); 
 242   4         }
 243   3         else if(lowpowertime==2)
 244   3         {
 245   4          LCD_SetOnePixel(0, 22, Enable); 
 246   4          LCD_SetOnePixel(0, 23, Enable);
 247   4          LCD_SetOnePixel(1, 23, Enable);
 248   4          LCD_SetOnePixel(2, 23, Disable);
 249   4         }
 250   3         else if(lowpowertime==3)
 251   3         {
 252   4          LCD_SetOnePixel(0, 22, Enable); 
 253   4          LCD_SetOnePixel(0, 23, Enable);
 254   4          LCD_SetOnePixel(1, 23, Enable);
 255   4          LCD_SetOnePixel(2, 23, Enable); 
 256   4         }
 257   3         else 
 258   3         {
 259   4          LCD_SetOnePixel(0, 22, Enable);
 260   4          LCD_SetOnePixel(2, 23, Disable);
 261   4          LCD_SetOnePixel(1, 23, Disable);
 262   4          LCD_SetOnePixel(0, 23, Disable); 
 263   4          lowpowertime=0;
 264   4         }
 265   3        }  
 266   2        if(JBE.Bat_Data.Bat_Val<3681)   
 267   2        {
 268   3         JBE.Bat_Data.BatPowerPecent=0;
 269   3        }
 270   2        else if(JBE.Bat_Data.Bat_Val<3743)
 271   2        {
 272   3        JBE.Bat_Data.BatPowerPecent=20;
 273   3        }
 274   2        else if(JBE.Bat_Data.Bat_Val<3824)
 275   2        {
 276   3        JBE.Bat_Data.BatPowerPecent=40;
 277   3        }
 278   2        else if(JBE.Bat_Data.Bat_Val<3981)
 279   2        {
 280   3        JBE.Bat_Data.BatPowerPecent=60;
 281   3        }
 282   2        else if(JBE.Bat_Data.Bat_Val<4150)
 283   2        {
 284   3        JBE.Bat_Data.BatPowerPecent=80;
 285   3        }
 286   2        else
 287   2        {
 288   3        JBE.Bat_Data.BatPowerPecent=100;
 289   3        }  
 290   2        }
 291   1        else if(IsChargOn==False)    //?????????
 292   1        {
C51 COMPILER V9.60.0.0   ADC_USER                                                          11/01/2022 15:53:28 PAGE 6   

 293   2         static uint8_t Pecent80Flag=0;
 294   2         static uint8_t Pecent60Flag=0;
 295   2         static uint8_t Pecent40Flag=0;
 296   2         static uint8_t Pecent20Flag=0;
 297   2         static uint8_t Pecent0Flag=0;
 298   2         JBE.Is_Bat_ChargFull=False;   //??????¦Å????????¦Ë????
 299   2         LCD_SetOnePixel(1, 22, Disable);  //????????
 300   2          
 301   2          
 302   2         if(JBE.Bat_Data.Bat_Val>3900)
 303   2         {
 304   3          if(Pecent80Flag==0)
 305   3          {
 306   4          JBE.Bat_Data.BatPowerPecent=100;
 307   4          LCD_SetOnePixel(0, 22, Enable);
 308   4          LCD_SetOnePixel(2, 23, Enable);
 309   4          LCD_SetOnePixel(3, 23, Enable);
 310   4          LCD_SetOnePixel(1, 23, Enable);
 311   4          LCD_SetOnePixel(0, 23, Enable);
 312   4          }
 313   3          else if(Pecent80Flag==1&&JBE.Bat_Data.Bat_Val>3920)
 314   3          {
 315   4          JBE.Bat_Data.BatPowerPecent=100;
 316   4          LCD_SetOnePixel(0, 22, Enable);
 317   4          LCD_SetOnePixel(2, 23, Enable);
 318   4          LCD_SetOnePixel(3, 23, Enable);
 319   4          LCD_SetOnePixel(1, 23, Enable);
 320   4          LCD_SetOnePixel(0, 23, Enable);
 321   4          Pecent80Flag=0;
 322   4          Pecent60Flag=0;
 323   4          Pecent40Flag=0;
 324   4          Pecent20Flag=0;
 325   4          Pecent0Flag=0;  
 326   4          }
 327   3          else
 328   3          {
 329   4          JBE.Bat_Data.BatPowerPecent=80;
 330   4          LCD_SetOnePixel(0, 22, Enable);
 331   4          LCD_SetOnePixel(2, 23, Disable);
 332   4          LCD_SetOnePixel(3, 23, Enable);
 333   4          LCD_SetOnePixel(1, 23, Enable);
 334   4          LCD_SetOnePixel(0, 23, Enable);   
 335   4          }
 336   3        
 337   3         }
 338   2         else if(JBE.Bat_Data.Bat_Val>3705)
 339   2         {
 340   3           Pecent80Flag=1;
 341   3         if(Pecent60Flag==0)
 342   3           {
 343   4           JBE.Bat_Data.BatPowerPecent=80;
 344   4           LCD_SetOnePixel(0, 22, Enable);
 345   4           LCD_SetOnePixel(2, 23, Disable);
 346   4           LCD_SetOnePixel(3, 23, Enable);
 347   4           LCD_SetOnePixel(1, 23, Enable);
 348   4           LCD_SetOnePixel(0, 23, Enable);   
 349   4           }
 350   3         else if(Pecent60Flag==1&&JBE.Bat_Data.Bat_Val>3725)
 351   3           {
 352   4           JBE.Bat_Data.BatPowerPecent=80;
 353   4           LCD_SetOnePixel(0, 22, Enable);
 354   4           LCD_SetOnePixel(2, 23, Disable);
C51 COMPILER V9.60.0.0   ADC_USER                                                          11/01/2022 15:53:28 PAGE 7   

 355   4           LCD_SetOnePixel(3, 23, Enable);
 356   4           LCD_SetOnePixel(1, 23, Enable);
 357   4           LCD_SetOnePixel(0, 23, Enable);
 358   4           //Pecent80Flag=0;
 359   4           Pecent60Flag=0;
 360   4           Pecent40Flag=0;
 361   4           Pecent20Flag=0;
 362   4           Pecent0Flag=0; 
 363   4           }
 364   3         else
 365   3           {
 366   4           JBE.Bat_Data.BatPowerPecent=60;
 367   4           LCD_SetOnePixel(0, 22, Enable);
 368   4           LCD_SetOnePixel(2, 23, Disable);
 369   4           LCD_SetOnePixel(3, 23, Enable);
 370   4           LCD_SetOnePixel(1, 23, Disable);
 371   4           LCD_SetOnePixel(0, 23, Enable);  
 372   4           }
 373   3      
 374   3         }
 375   2         else if(JBE.Bat_Data.Bat_Val>3600)
 376   2         {
 377   3          Pecent60Flag=1; 
 378   3          if(Pecent40Flag==0) 
 379   3          {
 380   4           JBE.Bat_Data.BatPowerPecent=60;
 381   4           LCD_SetOnePixel(0, 22, Enable);
 382   4           LCD_SetOnePixel(2, 23, Disable);
 383   4           LCD_SetOnePixel(3, 23, Enable);
 384   4           LCD_SetOnePixel(1, 23, Disable);
 385   4           LCD_SetOnePixel(0, 23, Enable);    
 386   4          }
 387   3          else if(Pecent40Flag==1&&JBE.Bat_Data.Bat_Val>3610)
 388   3          {
 389   4           JBE.Bat_Data.BatPowerPecent=60;
 390   4           LCD_SetOnePixel(0, 22, Enable);
 391   4           LCD_SetOnePixel(2, 23, Disable);
 392   4           LCD_SetOnePixel(3, 23, Enable);
 393   4           LCD_SetOnePixel(1, 23, Disable);
 394   4           LCD_SetOnePixel(0, 23, Enable);
 395   4           Pecent40Flag=0;
 396   4           Pecent20Flag=0;
 397   4           Pecent0Flag=0; 
 398   4          }
 399   3          else
 400   3          {
 401   4          JBE.Bat_Data.BatPowerPecent=40;
 402   4          LCD_SetOnePixel(0, 22, Enable);
 403   4          LCD_SetOnePixel(2, 23, Disable);
 404   4          LCD_SetOnePixel(3, 23, Enable);
 405   4          LCD_SetOnePixel(1, 23, Disable);
 406   4          LCD_SetOnePixel(0, 23, Disable);  
 407   4          }
 408   3       
 409   3         }
 410   2         else if(JBE.Bat_Data.Bat_Val>3528)
 411   2         {
 412   3         Pecent40Flag=1; 
 413   3         if(Pecent20Flag==0)
 414   3         {
 415   4           JBE.Bat_Data.BatPowerPecent=40;
 416   4           LCD_SetOnePixel(0, 22, Enable);
C51 COMPILER V9.60.0.0   ADC_USER                                                          11/01/2022 15:53:28 PAGE 8   

 417   4           LCD_SetOnePixel(2, 23, Disable);
 418   4           LCD_SetOnePixel(3, 23, Enable);
 419   4           LCD_SetOnePixel(1, 23, Disable);
 420   4           LCD_SetOnePixel(0, 23, Disable);  
 421   4         }
 422   3         else if(Pecent20Flag==1&&JBE.Bat_Data.Bat_Val>3550)
 423   3         {
 424   4           JBE.Bat_Data.BatPowerPecent=40;
 425   4           LCD_SetOnePixel(0, 22, Enable);
 426   4           LCD_SetOnePixel(2, 23, Disable);
 427   4           LCD_SetOnePixel(3, 23, Enable);
 428   4           LCD_SetOnePixel(1, 23, Disable);
 429   4           LCD_SetOnePixel(0, 23, Disable);
 430   4           Pecent20Flag=0;
 431   4           Pecent0Flag=0; 
 432   4         }
 433   3         else
 434   3         {
 435   4          JBE.Bat_Data.BatPowerPecent=20;
 436   4          LCD_SetOnePixel(0, 22, Disable);
 437   4          LCD_SetOnePixel(2, 23, Disable);
 438   4          LCD_SetOnePixel(3, 23, Enable);
 439   4          LCD_SetOnePixel(1, 23, Disable);
 440   4          LCD_SetOnePixel(0, 23, Disable);   
 441   4         }
 442   3        
 443   3         }
 444   2         else if(JBE.Bat_Data.Bat_Val>3120)
 445   2         {
 446   3         Pecent20Flag=1;
 447   3         if(Pecent0Flag==0)
 448   3         {
 449   4           JBE.Bat_Data.BatPowerPecent=20;
 450   4           LCD_SetOnePixel(0, 22, Disable);
 451   4           LCD_SetOnePixel(2, 23, Disable);
 452   4           LCD_SetOnePixel(3, 23, Enable);
 453   4           LCD_SetOnePixel(1, 23, Disable);
 454   4           LCD_SetOnePixel(0, 23, Disable);
 455   4         }
 456   3         else if(Pecent0Flag==1&&JBE.Bat_Data.Bat_Val>3140)
 457   3         {
 458   4           JBE.Bat_Data.BatPowerPecent=20;
 459   4           LCD_SetOnePixel(0, 22, Disable);
 460   4           LCD_SetOnePixel(2, 23, Disable);
 461   4           LCD_SetOnePixel(3, 23, Enable);
 462   4           LCD_SetOnePixel(1, 23, Disable);
 463   4           LCD_SetOnePixel(0, 23, Disable);
 464   4           Pecent0Flag=0;
 465   4         }
 466   3         else
 467   3         {
 468   4         lowpowertime++; 
 469   4         JBE.Bat_Data.BatPowerPecent=0;
 470   4         LCD_SetOnePixel(0, 22, Disable);
 471   4         LCD_SetOnePixel(2, 23, Disable);
 472   4         //LCD_SetOnePixel(3, 23, Enable);
 473   4         LCD_SetOnePixel(1, 23, Disable);
 474   4         LCD_SetOnePixel(0, 23, Disable);
 475   4         if(lowpowertime==1)
 476   4         {
 477   5          LCD_SetOnePixel(1, 22, Enable);  //?????????
 478   5          LCD_SetOnePixel(3, 23, Enable);
C51 COMPILER V9.60.0.0   ADC_USER                                                          11/01/2022 15:53:28 PAGE 9   

 479   5         }
 480   4         else if(lowpowertime==2)
 481   4         {
 482   5          LCD_SetOnePixel(1, 22, Disable); 
 483   5          LCD_SetOnePixel(3, 23, Disable);
 484   5          lowpowertime=0; 
 485   5         }
 486   4         }
 487   3         }
 488   2         else 
 489   2         {
 490   3         Pecent0Flag=1;
 491   3         lowpowertime++;
 492   3         JBE.Bat_Data.BatPowerPecent=0;
 493   3         LCD_SetOnePixel(0, 22, Disable);
 494   3         LCD_SetOnePixel(2, 23, Disable);
 495   3         //LCD_SetOnePixel(3, 23, Enable);
 496   3         LCD_SetOnePixel(1, 23, Disable);
 497   3         LCD_SetOnePixel(0, 23, Disable);
 498   3         if(lowpowertime==1)
 499   3         {
 500   4          LCD_SetOnePixel(1, 22, Enable);  //?????????
 501   4          LCD_SetOnePixel(3, 23, Enable);
 502   4         }
 503   3         else if(lowpowertime==2)
 504   3         {
 505   4          LCD_SetOnePixel(1, 22, Disable); 
 506   4          LCD_SetOnePixel(3, 23, Disable);
 507   4          lowpowertime=0; 
 508   4         }
 509   3          if(JBE.Bat_Data.Bat_Val<3000)//????????    ???ÓÍ??
 510   3          {
 511   4          // BAT_POWER_OFF();
 512   4          }
 513   3         }
 514   2        }
 515   1      
 516   1      }
 517           
 518          uint16_t Get_NTC_Temp(void)
 519          {
 520   1      if(JBE.NTC_Data.IsFistGetTemp==True)
 521   1      {
 522   2      JBE.NTC_Data.NTC_Init=JBE.NTC_Data.NTC_Temp;
 523   2      JBE.NTC_Data.IsFistGetTemp=False;
 524   2      }
 525   1      return JBE.NTC_Data.NTC_Temp;
 526   1      }
 527          
 528          uint16_t Get_NTC_Init(void)
 529          {
 530   1      return JBE.NTC_Data.NTC_Init;
 531   1      
 532   1      } 
 533          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3435    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    279      10
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.60.0.0   ADC_USER                                                          11/01/2022 15:53:28 PAGE 10  

   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
